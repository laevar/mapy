\documentclass[notes=hide,hyperref={dvipdfmx,pdfpagelabels=false}]{beamer}
\title{Einführung in Matlab - Einheit 1}
\subtitle{Streifzug durch Matlab, Vektoren und Matrizen, Numerische lineare Algebra}
\input{../slide_header}
\maketitle

\section{Streifzug durch MATLAB}

\subsection{Einleitung}
%-------------------------------------------------
%  Folie:
%-------------------------------------------------
\begin{frame}[fragile]\frametitle{MATLAB}

\begin{itemize}
\item MATLAB steht für \alert{Mat}rix \alert{lab}oratory; ursprünglich speziell Matrizenrechnung.
\item Entwickelt von Cleve Moler Ende der 70'er in FORTRAN.
\item Heutige Version ist in C/C++ programmiert.
\item Interaktives System für numerische Berechnungen und Visualisierungen.
\item Kein Computer-Algebra-System (Aber erweiterbar durch \texttt{symbolic math toolbox})
\end{itemize}
\end{frame}

%-------------------------------------------------
%  Folie:
%-------------------------------------------------
\begin{frame}[fragile]\frametitle{Vorteile von MATLAB}

\begin{itemize}
\item \emph{High-Level} Sprache:
\begin{itemize}
\item Programmieren ist leicht (aber auch beschränkter)
\item Schnelle Erfolge 
\item Sehr geeignet für Prototyping und Debugging
\end{itemize}
\item Vielfältige Visualisierungsmöglichkeiten.
\item MATLAB-Programme sind vollständig portierbar zwischen Architekturen (cross-plattform).
\item Integration zusätzlicher Toolboxes (Symb. Math T., PDE T., Wavelet T.)  
\item Ausgereifte Oberfläche.
\end{itemize}
\end{frame}

%-------------------------------------------------
%  Folie:
%-------------------------------------------------
\begin{frame}[fragile]\frametitle{Literatur}
\begin{thebibliography}{10}
\small
\bibitem{1} Matlab online-help :-).
\bibitem{2}
\alert{Matlab Guide}, D.J. Higham, N.J. Higham, SIAM, 2000, 
\bibitem{3} \alert{Introduction to Scientific Computing}, C.F. van Loan, Prentice Hall,
New Jersey, 1997,
\bibitem{4} \alert{Scientific Computing with MATLAB}, A. Quarteroni, F. Saleri, Springer, 2003,
\bibitem{5} \alert{Graphics and GUIs with MATLAB}, P. Marchand, O.Th. Holland, Chapman \& Hall, 2003, 3. Aufl.
\bibitem{6} \alert{MATLAB 7}, C. \"Uberhuber, St. Katzenbeisser, D. Praetorius, Springer 2005.
\bibitem{7} \alert {Using \textsc{Matlab}}, offizielle Handbücher.
\end{thebibliography}
\end{frame}


\subsection{Grundlegende Bedienung}
%-------------------------------------------------
%  Folie:
%-------------------------------------------------
\begin{frame}[fragile]\frametitle{MATLAB Fenster-Aufbau}
Starten von MATLAB: Eingabe von \mcode{matlab &} (in einem Terminal).
\centering\includegraphics[width=0.55\textwidth]{figures/Screenshot-MATLAB}

\begin{columns}[c]
\column{0.48\textwidth}
\begin{itemize}
\item \alert{Launch Pad:} Startmenü.
\item \alert{Command Window:} Befehlseingabe und Standardausgabe.
\end{itemize}
\column{0.48\textwidth}
\begin{itemize}
\item \alert{Workspace:} Ansicht von Variablen und deren Art und Grösse; Ändern der
Einträge 
\item \alert{Grafik:} normalerweise in seperaten Fenstern.
\end{itemize}

\end{columns}
\end{frame}

%-------------------------------------------------
%  Folie:
%-------------------------------------------------
\begin{frame}[fragile]\frametitle{Command Window - Befehle }
\begin{itemize}
\item Erster Befehl
\begin{lstlisting}
>> 2+2
ans = 4
\end{lstlisting}
%\item Variable \mcode{ans} jetzt im Workspace.
\item Editieren alter Eingaben:  $\uparrow$, $\downarrow$ (wie
in Unix)
%\item aktuelles Verzeichnis: \mcode{pwd}
\item Mit \mcode{;} am Ende jeder Befehlszeile wird Standardausgabe unterdrückt.
\begin{lstlisting}
>> 2+2;
\end{lstlisting}
\item Hilfe zu Befehlen: \mcode{help <command>} oder \mcode{doc <command>}
\item Zuweisung 
\begin{lstlisting}
>> a = 2+2;
\end{lstlisting}
\item Funktionsaufruf 
\begin{lstlisting}
>> sin(2)
ans = 0.9093
\end{lstlisting}
\item Verlassen von MATLAB: \mcode{quit} oder \mcode{exit}
\end{itemize}
\end{frame}


%-------------------------------------------------
%  Folie:
%-------------------------------------------------
\begin{frame}[fragile]\frametitle{Workspace - globale Variablen}
\begin{itemize}
\item Alle definierten (globalen) Variablen werden im Workspace gespeichert.
\item Zugriff während einer MATLAB-Sitzung.
\item Inhalt des Arbeitsspeichers: \mcode{whos} oder \mcode{who}
\begin{lstlisting}
>> whos
  Name      Size            Bytes  Class   

  ans       1x1                 8  double    
\end{lstlisting}
\item Löschen von Variablen : \mcode{clear <var>};\\
\mcode{clear} löscht den gesamten Arbeitsspeicher (Workspace).
\end{itemize}
\end{frame}




\subsection{Erste Schritte}
%-------------------------------------------------
%  Folie:
%-------------------------------------------------
\begin{frame}[fragile]\frametitle{Erste Schritte}
\begin{itemize}
\item MATLAB als Taschenrechner \newline (Ergebnis wird in \mcode{ans} gespeichert.) 
\begin{lstlisting}
>> 1+(sin(pi/2)+ exp(2))*0.5
ans = 5.1945
\end{lstlisting}
\item Eingabe von (Zeilen-)Vektoren
\begin{lstlisting}
>> x = [1 2 3]  
\end{lstlisting}
\item Transponieren und speichern in  Variable \mcode{b}
\begin{lstlisting}
>> b = transpose(x)
\end{lstlisting}
\end{itemize}
\end{frame}

%-------------------------------------------------
%  Folie:
%-------------------------------------------------
\begin{frame}[fragile]\frametitle{Erste Schritte II}
\begin{itemize}
\item Erzeugen einer Matrix
\begin{lstlisting}
A = [0 2 3 ; 4 5 6; 7 8 9];
\end{lstlisting}
\item Lösen des Gleichungssystems $A \cdot z=b$
\begin{lstlisting}
>> z = A \ b
\end{lstlisting}
\item Probe 
\begin{lstlisting}
>> A*z
\end{lstlisting}
\end{itemize}
\end{frame}
%-------------------------------------------------
%  Folie:
%-------------------------------------------------
\begin{frame}[fragile]\frametitle{Erste Schritte III}
\begin{itemize}
\item Berechnen der Determinante von $A$
\begin{lstlisting}
>> det(A)
\end{lstlisting}
\item Hilfe zu \mcode{det} 
\begin{lstlisting}
>> help det
 DET    Determinant.
    DET(X) is the determinant of the square matrix X.
    Use COND instead of DET to test for matrix singularity.
\end{lstlisting}
\item Erzeugen einer Einheitsmatrix
\begin{lstlisting}
>> B = eye(3,3)
\end{lstlisting}
\end{itemize}
\end{frame}
%-------------------------------------------------
%  Folie:
%-------------------------------------------------
\begin{frame}[fragile]\frametitle{Erste Schritte IV}
\begin{itemize}
\item Matrizenoperationen
\begin{lstlisting}
>> A+B, A-B, A*B, inv(A)
\end{lstlisting}
\item Anwendung von Vektoren
\begin{lstlisting}
>> y = sqrt(x)
y =
    1.0000    1.4142    1.7321
\end{lstlisting}
\end{itemize}
\end{frame}
%-------------------------------------------------
%  Folie:
%-------------------------------------------------
\begin{frame}[fragile]\frametitle{Erste Schritte V}
\begin{itemize}
\item Komponentenweise Multiplikation
\begin{lstlisting}
>> y = x.*x
 y =
     1     4     9
\end{lstlisting}
\item Zeilenvektor mit Werten von $1$ bis $100$
\begin{lstlisting}
>> a = [1:100];
\end{lstlisting}
\item Berechne $\sum_{j=1}^{100} \frac{1}{j^2}$
\begin{lstlisting}
>> (1./a)*transpose(1./a)
ans = 1.6350
\end{lstlisting}
\end{itemize}
\end{frame}

\subsection{Etwas komplexeres Beispiel}
%-------------------------------------------------
%  Folie:
%-------------------------------------------------
\begin{frame}[fragile]\frametitle{Die Mandelbrot-Menge}
\begin{columns}[c,onlytextwidth]
\column{0.6\textwidth}
\pgfimage[width=\textwidth]{../figures/mandel}
\column{0.4\textwidth}
Die Mandelbrot-Menge ist die Menge von Punkten $c \in \mathbb{C}$
bei denen die Folge $(z_n)_n$, die durch
\begin{align*} 
z_0&:=c\\
z_{n+1} &= z_n^2 +c, \quad n \in \mathbb{N} 
\end{align*}
definiert ist, beschränkt ist.
\end{columns}
\end{frame}
%-------------------------------------------------
%  Folie:
%-------------------------------------------------
\begin{frame}[fragile]\frametitle{Die Mandelbrot-Menge}
\lstinputlisting{mandel.m}
\end{frame}
%-------------------------------------------------
%  Folie:
%-------------------------------------------------
\begin{frame}[fragile]\frametitle{Verwendete Befehle}
\begin{itemize}
\item \mcode{linspace(a,b,n)}\\ ist ein Vektor mit n Einträgen der Form
$a, a+(b-a)/(n-1), \dots ,b$
\item \mcode{[X,Y] = meshgrid(x,y)}\\ erzeugt Matrizen 
\begin{equation*}
X = \left( \begin{array}{ccc} x_1 & \ldots & x_n\\  & \vdots & \\x_1 & \ldots & x_n\end{array}
\right), \quad  Y = \left( \begin{array}{ccc} y_1 & \ldots & y_1\\  & \vdots & \\y_n & \ldots & y_n\end{array}  \right)
\end{equation*}
\item \mcode{C = complex(X,Y)}\\ erzeugt $C=(C(j,k))_{jk}$ mit
$C(j,k)=X(j,k)+i \ Y(j,k)$ 
\end{itemize}
\end{frame}
%-------------------------------------------------
%  Folie:
%-------------------------------------------------
\begin{frame}[fragile]\frametitle{Verwendete Befehle}
\begin{itemize}
\item \mcode{B = isfinite(A)}\\ Matrix $B$ hat gleiche Gr\"o{\ss}e wie $A$. Die Einträge sind $1$, 
wenn der entsprechende Eintrag von $B$ finit ist und $0$ sonst.  
\item \mcode{image(x,y,A)}\\ erzeugt eine Grafik auf der Basis des Gitters
  $(x,y)$ mit Werten $A$. Durch den entsprechenden Eintrag von $A$ wird die
  Farbe bestimmt.  
\item \mcode{title}\\ Überschrift der Grafik.
\item \mcode{for}, \mcode{end}\\ 
Schleife (Details später).
\end{itemize}
\end{frame}

\subsection{Skript-Files und der Editor}

%----------------------------
% Folie 
%----------------------------
\begin{frame}[fragile]\frametitle{Motivation Skript-File}
\alert{Probleme beim Mandelbrot:} 
\begin{itemize}
\item
Bei jeder Änderung von z.B. \mcode{it_max} muss alles erneut im
interaktiven Modus eingegeben werden.
\item 
Abrufen der Befehle bei späteren Sitzungen ist kaum möglich. 
\item Bei komplexen Algorithmen wird es unübersichtlich.
\end{itemize}
\alert{Ausweg:} Die Befehlsfolge wird in einer Datei
abgelegt. MATLAB arbeitet dann sukzessive die einzelnen Kommandos
ab. 
\end{frame}

%----------------------------
% Folie 
%----------------------------
\begin{frame}[fragile]\frametitle{Erzeugen eines Programms}
\begin{itemize}
\item Starten des Editors: 
\begin{lstlisting}
>> edit datei_name 
\end{lstlisting}
öffnet die Datei \mcode{datei_name}.
\item Speichern der Datei mit Hilfe des Menüs: \mcode{File->Save}
  bzw. \mcode{File->Save As} oder per Shortcut.
\item Kommentarzeilen beginnen mit \mcode{\%}.
\end{itemize}
\alert{Achtung:} Alle MATLAB-Dateien haben die Endung '.m'. Man
spricht deswegen auch von $m$-Files.
\end{frame}

%----------------------------
% Folie 
%----------------------------
\begin{frame}[fragile]\frametitle{Struktur von Skript-Files}
\begin{itemize}
\item Skript-Files bestehen aus einer Sequenz von Befehlen, die
  nacheinander abgearbeitet werden. 
\item Am Anfang des Files als Kommentar: 
\begin{itemize}
\item Name des Programms 
\item (kurze) Beschreibung
\item Author-Informationen und Datum
\end{itemize}

\item operiert auf Daten im \textit{Workspace}.

\item Gestartet wird das Programm \mcode{name.m} durch Eingabe von
  \mcode{name}.

\item Beschreibung des Skript-Files:
\begin{lstlisting}
>> help plot_poly
 ------------------------------------
      plot_poly.m    
   zeichnet den Graphen eines Polynoms 
   Gerd Rapin           1.11.2003
 -------------------------------------------
\end{lstlisting}

\end{itemize}
\end{frame}

\subsection{Function-Files}

%----------------------------
% Folie 
%----------------------------
\begin{frame}[fragile]\frametitle{Functions - Graph eines Polynoms}

\alert{Aufgabe:}\\
Zeichnen Sie  den Graphen eines Polynoms
\vspace*{-0.4cm}
\[ p(x)= \sum_{i=0}^N a_i x^i, \quad a_i \in \mathbb{R} 
\vspace*{-0.4cm} \]
\alert{Problem:}\\
Zu Werten $(x_i)_{i=1}^n$ muß man $(p(x_i))_{i=1}^n$ berechnen,
d.h. Funktionswerte müssen sehr oft berechnet werden.

\alert{Lösung:}\\
Es gibt Funktionen in MATLAB.
\end{frame}

%----------------------------
% Folie 
%----------------------------
\begin{frame}[fragile]\frametitle{Skalare Version}
\begin{lstlisting}
function y=ausw_poly1(a,x)
%----------------------------------------------------
% ausw_poly berechnet den Funktionswert von 
%           p(x)=a_1 +a_2 x + a_3 x^2+ ... +a^n x^(n-1)
%           INPUT:  a Vektor der Koeffizienten 
%                   x  auszuwertender Punkt
%           OUTPUT: y  Funktionswert (y=p(x))
%  Gerd Rapin           1.11.2003
%------------------------------------------------------

n = length(a);
aux_vector = x.^(0:n-1);
y = aux_vector*transpose(a);
\end{lstlisting}
\end{frame}
%----------------------------
% Folie 
%----------------------------
\begin{frame}[fragile]\frametitle{Vektorielle Version}
\lstinputlisting{ausw_poly2.m}
\end{frame}
%----------------------------
% Folie 
%----------------------------
\begin{frame}[fragile]\frametitle{Plotten des Polynoms}
\lstinputlisting{plot_poly.m}
\end{frame}
%----------------------------
% Folie 
%----------------------------
\begin{frame}[fragile]\frametitle{Plotten des Polynoms}
\[p(x) = (x-1)(x-2)(x-3) \]
\begin{center}
\includegraphics[width=0.6\textwidth]{figures/polynom_03_11} 
\end{center}

\end{frame}

%----------------------------
% Folie 
%----------------------------
\begin{frame}[fragile]\frametitle{Struktur von Function-Files}
Beispiel: 'my-file.m'
\begin{lstlisting}
function [Out_1,..,Out_k] = myfunction(In_1,..,In_l)
% Beschreibung der Funktion
 ..
Out_1=..
 ..
Out_k=..
\end{lstlisting}
Soll keine Variable zurückgegeben werden, so besteht die erste Zeile aus
\begin{lstlisting}
function myfunction(In_1,..,In_k)
\end{lstlisting}

\alert{Wichtig:} Funktionsname muss identisch sein mit dem Dateinamen.
\end{frame}
%----------------------------
% Folie 
%----------------------------
\begin{frame}[fragile]\frametitle{Function-Files}
\begin{itemize}
\item Funktionen sind mit Kommentaren zu versehen:
\begin{itemize}
\item (kurze) Beschreibung
\item Input-Argumente
\item Output-Argumente
\item Author-Informationen und Datum
\end{itemize}
\item Variablen lokal, d.h.
\begin{itemize}
 \item Variablen des Workspace sind innerhalb nichr verfügbar
\item im Programm definierte Variablen werden nicht im  Workspace gespeichert.
\end{itemize}
 
%oder kurz \alert{ \mcode{function myfile(In_1,...,In_k)}}.
\end{itemize}
\end{frame}

\subsection{Verwaltung von Dateien}

%----------------------------
% Folie 
%----------------------------
\begin{frame}[fragile]\frametitle{Verwalten von m-Files}
\begin{itemize}
\item \alert{ \mcode{doc name}} startet das grafische Hilfefenster mit einem ausführlichen Hilfetext zu dem jeweiligen Programm.
\item \alert{ \mcode{lookfor name}} sucht nach dem Stichwort \mcode{name} in den
  Kommentaren zu den Funktionen. Ansonsten kann auch das grafische Hilfefenster zur Rate gezogen werden.
\item  \alert{ \mcode{what}} zeigt die m-Files im aktuellen Verzeichnis an.
\item  \alert{ \mcode{type name}} zeigt den Inhalt von \mcode{name.m} im 'Command  Window' an.
\item  \alert{ \mcode{which name}} gibt den genauen Pfad an, in dem die  Funktion
  \mcode{name.m} gespeichert ist. 
\end{itemize}
\end{frame}

%----------------------------
% Folie 
%----------------------------
\begin{frame}[fragile]\frametitle{Starten von Programmen}
\begin{itemize}
\item Befindet man sich im selben Verzeichnis wie das Programm
  \mcode{name.m}, so kann man das Programm starten durch Eingabe von  
\mcode{name}. 
\item Danach durchsucht MATLAB die in \mcode{path} angegebenen
  Verzeichnisse nach dem Programm.
\item Mit dem Befehl \mcode{addpath pfadname} kann man eigene Suchpfade
  hinzufügen.  
\item Durch \mcode{rmpath pfadname} kann man Suchpfade entfernen.  
\end{itemize}
\end{frame}


%----------------------------
% Folie 
%----------------------------
\begin{frame}[fragile]\frametitle{Priorität beim Programmaufruf}
\begin{enumerate}
\item  Testet, ob der Name eine Variable ist.
\item  Testet, ob der Name eine Unterfunktion ist. Eine
  Unterfunktion ist ein Programm, das in derselben Datei wie der
  Aufruf steht.
\item  Testet, ob das Programm im aktuellen Verzeichnis steht.
\item  Testet, ob der Name eine \textit{private function} ist.
\item  Testet, ob das Programm im Suchpfad enthalten ist. 
\end{enumerate}
\end{frame}




\section{Vektoren und Matrizen}



\subsection{Erzeugen von Vektoren}
%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Vektoren I}
\begin{itemize}
\item Erzeugen 'per Hand'
\begin{lstlisting}
> b = [1 2 4]
b =
     1     2     4
\end{lstlisting}
\item Abfragen der Einträge von $b$
\begin{lstlisting}
>> b(2)
ans =      2
\end{lstlisting}
Index $\equiv$ Position im Vektor\\

\alert{Achtung}: Indizes beginnen immer mit $1$!

\end{itemize}
\end{frame}

%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Doppelpunkt - Notation}
$x:s:z$ erzeugt einen Vektor der Form 
\[ (x,x+s,x+2s,x+3s, \ldots , z). \]
\begin{lstlisting}
>> a = 2:11
a =
 2  3  4  5  6  7  8  9  10  11

>> c = -2:0.75:1
c =
 -2.0000 -1.2500 -0.5000 0.2500 1.0000
\end{lstlisting}
\end{frame} 

%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Vektoren II}
\begin{itemize}
\item \mcode{length(a)} gibt die Länge des Vektors $a$ an.
\item \mcode{linspace(x1,x2,N)} erzeugt den Vektor
\[ x1, x1+\frac{x2-x1}{N-1}, x1+2 \frac{x2-x1}{N-1}, \dots ,x2  \]
der Länge $N$.
\begin{lstlisting}
>> linspace(1,2,4)
ans =
    1.0000    1.3333    1.6667    2.0000
\end{lstlisting}
\item \mcode{logspace(x1,x2,N)} wie \mcode{linspace}, nur logarith. Skalierung
\end{itemize}
\end{frame}

\subsection{Erzeugen von Matrizen}
%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Erzeugen von Matrizen}
\begin{itemize}
\item Erzeugen 'per Hand'
\begin{lstlisting}
>> B = [1 3 4; 5 6 7]
B =
     1     3     4
     5     6     7
\end{lstlisting}
\item Erzeugen von 'Einheitsmatrizen' 
\begin{lstlisting}
>> eye(2,3)
ans =
     1     0     0
     0     1     0
\end{lstlisting}
\mcode{eye(n,m)} erzeugt eine $(n \times m)$- Matrix mit $1$ auf der
Hauptdiagonalen und 0 sonst.
\end{itemize}
\end{frame} 
%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Erzeugen von Matrizen II}
\begin{itemize}
\item \mcode{zeros(n,m)}: $(n \times m)$- Matrix mit $0$ als Einträge.
\item \mcode{ones(n,m)}: $(n \times m)$- Matrix mit $1$ als Einträge.
\item Blockmatrizen
\begin{lstlisting}
>> C = [B zeros(2,2); eye(2,3) eye(2,2)]
C =
     1     3     4     0     0
     5     6     7     0     0
     1     0     0     1     0
     0     1     0     0     1
\end{lstlisting}
\alert{Achtung:} Matrizen in einer Zeile müssen dieselbe
Zeilenanzahl haben und Matrizen in einer Spalte dieselbe Spaltenanzahl.
\end{itemize}
\end{frame} 
%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Erzeugen von Matrizen III}
\begin{itemize}
\item \mcode{repmat(A,n,m)}: Blockmatrix mit $(n \times m)$
  aus A bestehenden Blöcken
\begin{lstlisting}
>> D = repmat(B,1,2)
D =
     1     3     4     1     3     4
     5     6     7     5     6     7
\end{lstlisting}
\item \mcode{blkdiag(A,B)}: Blockdiagonalmatrix.
\item \mcode{diag(v,k)}: Matrix der Größe $(n+|k|) \times
  (n+|k|)$ mit den Einträgen des Vektors $v$ auf der $k$-ten Nebendiagonalen. 
\end{itemize}
\end{frame}

\subsection{Manipulation von Matrizen}
%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Beispiel-Matrizen}
\begin{itemize}
\item Einen Überblick erhält man durch \mcode{help gallery}
\item Ein Beispiel
\begin{lstlisting}
>> E = gallery('moler',4)
E =
     1    -1    -1    -1
    -1     2     0     0
    -1     0     3     1
    -1     0     1     4
\end{lstlisting}
\item Hilfe zur Matrix 'moler' erhält man durch \mcode{help private/moler}
\item weitere Matrizen: \mcode{magic, hilb, vander}
\end{itemize}
\end{frame}
%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Zugriff auf Matrizen}
\begin{columns}[c]%
\column{0.45\textwidth}%
\begin{lstlisting}[basicstyle=\tiny]
>>   A = [1 2 3; 4 5 6; 7 8 9]
A =
     1     2     3
     4     5     6
     7     8     9
\end{lstlisting}%
\end{columns}%
\begin{columns}[t,onlytextwidth]
\column{0.45\textwidth}
Abfragen eines Eintrags
\begin{lstlisting}
>> A(2,1)
ans =
     4
\end{lstlisting}
\column{0.45\textwidth}
Abfrage von Blöcken
\begin{lstlisting}
>> A(2:3,1:2)
ans =
     4     5     
     7     8     
\end{lstlisting}
\end{columns}
\begin{columns}[t,onlytextwidth]
\column{0.45\textwidth}
Abfrage einer Zeile
\begin{lstlisting}
>> A(2,:)
ans =
     4     5     6
\end{lstlisting}
\column{0.45\textwidth}
Abfrage mehrerer Zeilen
\begin{lstlisting}
>> A([1 3],:)
ans =
     1     2     3
     7     8     9
\end{lstlisting}
\end{columns}
\end{frame}
%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Löschen}
\begin{columns}[c]%
\column{0.45\textwidth}%
\begin{lstlisting}[basicstyle=\tiny]
>>   A = [ 1 2 3; 4 5 6; 7 8 9]
A =
     1     2     3
     4     5     6
     7     8     9
\end{lstlisting} 
\end{columns}%
\begin{columns}[t]
\column{0.45\textwidth}%
Löschen einer Zeile
\begin{lstlisting}
>> A(2,:) = []
A =
     1     2     3
     7     8     9
\end{lstlisting}
\column{0.45\textwidth}%
Löschen von Spalten
\begin{lstlisting}
> A(:,[1 3]) = []
A =
     2
     5
     8
\end{lstlisting}
\end{columns}
\end{frame}

\subsection{Matrix- und Vektoroperationen}
%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Matrizenoperationen}

Standard-Matrix Operationen \mcode{+,-,*}
\begin{lstlisting}
>> A = [1 2; 3 4]; B = 2*ones(2,2);
\end{lstlisting}
\begin{columns}[t]%
\column{0.25\textwidth}%
Multiplikation
\begin{lstlisting}
>>  A*B

ans =

     6     6
    14    14
\end{lstlisting}
\column{0.25\textwidth}%
Addition
\begin{lstlisting}
>> A+B

ans =

     3     4
     5     6
\end{lstlisting}
\column{0.25\textwidth}%
Subtraktion
\begin{lstlisting}
>> A-B

ans =

    -1     0
     1     2
\end{lstlisting}
\end{columns}
\end{frame}
%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Andere Operatoren}
\begin{itemize}
\item \mcode{A\\B}:  Lösung $X$ von \mcode{A*X=B}. \\

\item \mcode{A/B}: Lösung $X$ von \mcode{X*A=B}.\\

\item \mcode{inv(A)}: Inverse von $A$.\\

\item \mcode{A'} oder \mcode{ctranspose(A)}: komplex Transponierte von $A$. \\

\item \mcode{A.'} oder \mcode{transpose(A)}: Transponierte von $A$. \\

\item \mcode{A^z}: (quadratische Matrizen) $\underbrace{A*A*\cdots *A}_{z-mal}$ \\

\item \mcode{size(A)}: Gr\"o{\ss}e einer Matrix $A$ . 
\end{itemize}
\end{frame}
%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Punktnotation}
\begin{lstlisting}
>> A = [1 2; 3 4]; B = 2*ones(2,2);
\end{lstlisting}
\begin{itemize}
\item \mcode{C = A.*B} ergibt $C$ mit $C(i,j)=A(i,j)*B(i,j)$.
\begin{lstlisting}
C =
     2     4
     6     8
\end{lstlisting}
\item \mcode{C = A./B} ergibt $C$ mit $C(i,j)=A(i,j)/B(i,j)$.
\begin{lstlisting}
C =
    0.5000    1.0000
    1.5000    2.0000
\end{lstlisting}
\end{itemize}
\end{frame}
%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Punktnotation}
\begin{itemize}
\item \mcode{C = A.\B} ergibt $C$ mit $C(i,j)=B(i,j)/A(i,j)$.
\begin{lstlisting}
C =
    2.0000    1.0000
    0.6667    0.5000
\end{lstlisting}
\item \mcode{C = A.^B} ergibt $C$ mit $C(i,j)=A(i,j)^{B(i,j)}$
\begin{lstlisting}
C =
     1     4
     9    16
\end{lstlisting}
\end{itemize}
\alert{Achtung:} Dimension von $A$ und $B$ gleich. \\Matrizen können durch
Skalare ersetzt werden, z.B. \mcode{ A.^2}.
\end{frame}
%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Skalarprodukt}
\begin{itemize}
 \item Vektoren $a=(a_1, \dots ,a_n)$, $b=(b_1, \dots b_n)$ \\
\item Skalarprodukt: $a b^t$\\
\item Summe der Einträge von $a$: $(1, \dots , 1) a^t$\\
\end{itemize}
Beispiel:
\begin{lstlisting}
>> a=1:100; b=linspace(0,1,100);
>> a*transpose(b)
ans =
   3.3667e+03
>> ones(1,100)*transpose(a)
ans =
        5050
\end{lstlisting}  

\end{frame}





\end{document}