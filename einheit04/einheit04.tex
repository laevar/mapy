\documentclass[hyperref={dvipdfmx,pdfpagelabels=false}]{beamer}
\title{Einführung in Matlab - Einheit 4}
\subtitle{Polynome u. Interpolation, Visualisieren, In- Output, Debugging}
\input{../slide_header}
\maketitle

\section{Polynome und Interpolation}

\subsection{Polynomiale Interpolation selbstgemacht}
% 
% Slide
% 
\begin{frame}[fragile]\frametitle{Polynomiale Interpolation}
\begin{columns}[b]
 \column{0.6\textwidth}
Suche ein Polynom vom Grad 3
\[ p(x)= p_0 +p_1 x +p_2 x^2 +p_3 x^3,  \]
 dass durch die vier Punkte
$(0,1)$, $(1,1)$, $(2,4)$, $(5,3)$
verläuft.
\column{0.4\textwidth}
\includegraphics[width=\textwidth]{figures/grafik_6}
\end{columns}
$\Rightarrow  \alert{ p(0)=1, \ p(1)=1, \ p(2)=4, \ p(5)=3}$

$\Rightarrow \quad$ Lineares GLS \alert{ $Ap=b$} mit
{\scriptsize \[ A= \left( \begin{array}{cccc}
1 & 0 & 0 & 0\\
1 & 1 & 1 & 1\\
1 & 2 & 2^2 & 2^3 \\
1 & 5 & 5^2 & 5^3 \\
\end{array} \right), \
p=\left( \begin{array}{c} 
p_0 \\ p_1 \\ p_2 \\p_3\\
\end{array} \right),
\
b=\left( \begin{array}{c} 
1 \\ 1 \\ 4 \\ 3\\
\end{array} \right),
\]}  
\end{frame}
% 
% Slide
% 
\begin{frame}[fragile]\frametitle{Polynomiale Interpolation II}
Suche ein Polynom vom Grad n
\[ p(x)= p_0 +p_1 x +p_2 x^2 +p_3 x^3+ \dots +p_n x^n,  \]
 dass durch die  $n+1$ Punkte $(x_i,y_i)_{i=0}^n$
verläuft.\\[1cm]

\textbf{Beispiel}: Interpolation von
\[ (x_i,y_i)_{i=0}^{12} \]
mit \mcode{x=linspace(-5,5,13)} und $y_i=\frac{1}{1+x_i^2}$. 
\end{frame}
% 
% Slide
% 
\begin{frame}[fragile]\frametitle{Polynomiale Interpolation: Beispiel}
\begin{center}
\includegraphics[width=0.8\textwidth]{figures/grafik_7}
\end{center}
\end{frame}
% 
% Slide
% 
\begin{frame}[fragile]\frametitle{Programm 1}
\lstinputlisting{interpol2.m}
\end{frame}
% 
% Slide
% 
\begin{frame}[fragile]\frametitle{Programm 2}
\lstinputlisting{interpol3.m}
\end{frame}

\subsection{Polynome - Matlab built-in}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Polynome}
In MATLAB werden Polynome
\[ p(x)=p_1 x^n+ p_2 x^{n-1}+ \cdots + p_{n+1} \]
repr\"asentiert durch einen Zeilenvektor $p=[p(1) \ p(2) \ \dots
\   p(n+1)]$. \vspace*{0.5cm}\\

\alert{ Vorsicht:} Normalerweise werden Polynome in der Form
$\sum_{i=0}^n p_ix^i$ dargestellt. In MATLAB dagegen ist die
Darstellung invers und beginnt bei $1$.
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Problemstellungen}
\begin{itemize}
\item [1.] \alert{ Auswerten:} Bei gegebenen Koeffizienten, das
  zugeh\"orige Polynom an bestimmten Stellen auswerten.
\item [2.] \alert{ Nullstellenbestimmung:} Bestimme zu gegebenen
  Koeffizienten die Nullstellen des zugeh\"origen Polynoms.
\item [3.]  \alert{ Interpolation}: Bestimme zu einer gegebenen Menge von
  Punkten $(x_i,y_i)_{i=0}^n$ ein Polynom $n$.-ten Grades, das durch
  diese Punkte verl\"auft.
\end{itemize}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Auswerten}
\begin{lstlisting}
y = polyval(<p>,<x>)
\end{lstlisting}
mit Koeffizientenvektor $p$ und Ort $x$ berechnet die Funktionswerte $y$.
($x$ kann eine Matrix sein)

\medskip
\alert{Beispiel:} $p(x):= x^3 - x^2 +1$\\
\begin{columns}[c]
\column{0.55\textwidth}
\begin{lstlisting}
x = -2:0.1:2; 
y = polyval([1 -1 0 1],x); 
plot(x,y,'r--','Linewidth',3);
\end{lstlisting}
\column{0.45\textwidth}
%\includegraphics[width=5cm, height=3cm]{grafik_1}
\includegraphics[width=\textwidth]{figures/polynom1}
\end{columns}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Bestimmung von Nullstellen}
\begin{lstlisting}
z = roots(<p>)
\end{lstlisting}
Nullstellen $z$ mit Koeffizientenvektor $p$.

\textbf{Beispiel:} \\
$p(x):= x^3 - x^2 +1$\\
\begin{columns}[c]
\column{0.58\textwidth}
\begin{lstlisting}
roots([1 -1 0 1])
\end{lstlisting}
\begin{matlab}
ans =
   0.8774 + 0.7449i
   0.8774 - 0.7449i
  -0.7549  
\end{matlab}
\begin{lstlisting}
x = -1:0.1:1;
[X,Y] = meshgrid(x,x);
Z=abs(polyval([1 -1 0 1],X+i*Y)); 
surf(X,Y,Z)
\end{lstlisting}
\column{0.43\textwidth}
\includegraphics[width=\textwidth]{figures/polynom2}
\end{columns}
\end{frame}


\subsection{Interpolation}
% 
% Slide
%
\begin{frame}[fragile]\frametitle{Interpolation}
Suche zu  ein Polynom $p$ gegebenen Punkten $(x_i,y_i)_{i=0}^n$
$m$.-ten Grades
\begin{matlabin}
p = polyfit(x,y,m)
\end{matlabin}
\begin{itemize}
 \item $m=n$:\\ 
$p(x_i)=y_i$ f\"ur $i=0, \dots ,n$.
\item  $m<n$:\\ 
Least Square L\"osung, d.h. das Polynom $p$ der Ordnung $m$,
welches 
\[ 
\sum_{i=0}^n (p(x_i)-y_i)^2
\]
minimiert. 
\end{itemize}

\end{frame}

%
% Slide
%
\begin{frame}[fragile]\frametitle{Data Fitting}
\begin{lstlisting}
yi = interp1(x,y,xi,<method>)
\end{lstlisting}
Dabei sind $(x,y)$ die gegebenen Punkte, $xi$ sind die Stellen, an die
die Interpolante berechnet wird und $yi$ sind die entsprechenden
Funktionswerte. 

\mcode{<method>}:
%{\scriptsize
\begin{tabular}{ll}
\mcode{'nearest'} &  stückweise konstante Approximation \\
\mcode{'linear'}  & Lineare Interpolation \\ 
\mcode{'spline'} & stückweise kubischer Spline $u$ ($u \in C^2$,
$u|_{[x_i,x_{i+1}]} \in \mathbb{P}_3$) \\
\mcode{'cubic'} & kubische Hermite Interpolation\\ 
\end{tabular}
%}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Beispiel}
\hfil\includegraphics[width=0.8\textwidth]{figures/data_fitting}\hfil
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Bemerkungen}
\begin{itemize}
\item  Nur für die Spline-Methoden können   bei \mcode{interp1}  auch
  Stellen außerhalb des
  Interpolationsintervalls berechnet werden.
\item Data Fitting kann auch über die Oberfläche durchgeführt werden.
 Plotten Sie die Daten und wählen Sie \mcode{Basic Fitting} im Men\"u
 \mcode{Tools}. 
\end{itemize}
\end{frame}
%
% Slide
% 
% \begin{frame}[fragile]\frametitle{Lineare Regression}
% \begin{lstlisting}
% % Example for Linear Regression 
% x = (1:0.5:4)';
% y = exp(x);
% plot(x,y,'o');
% hold on;
% pause;
% %--- Determine least square fit for
% 
% %    f(t)=a(1) + a(2) t + a(3) t^2
% 
% n=length(x);
% A = [ ones(n,1), x, x.^2 ];
% a = A \ y;
% %--- Plot new curve
% x1 = 1:0.1:4;
% y1 = a(1) + a(2)*x1 + a(3)*x1.^2;
% plot(x1,y1,'LineWidth',2)
% \end{lstlisting}
% \end{frame}

\section{Visualisieren von 3D-Daten}

%
% Slide
% 
\begin{frame}[fragile]\frametitle{Nicht-reguläre Daten}
\begin{itemize}
\item Daten liegen h\"aufig in Form von Vektoren $(x,y,z)$ vor. Man m\"ochte
  eine Funktion $F$ mit $z(i) = F(x(i),y(i))$ plotten.
\item Befehle \mcode{surf} und \mcode{mesh} funktionieren nur wenn  die
  Einträge in $x$ und $y$ monoton sind und die Daten auf einem kartesischen
  Gitter vorliegen.
\item Ausweg: Interpolieren der Daten auf ein entsprechendes Gitter. 
\end{itemize}
\end{frame}
%
% Slide
% 
\begin{frame}[fragile]\frametitle{Beispiel}
\begin{lstlisting}
load seamount
plot(x,y,'.','markersize',10)
figure, plot3(x,y,z,'.')
\end{lstlisting}
\begin{center}
\includegraphics[width=0.6\textwidth]{figures/beispiel_scattered_data}
\end{center}
\end{frame}
%
% Slide
% 
\begin{frame}[fragile]\frametitle{Beispiel}
\begin{lstlisting}
xi = linspace(min(x),max(x),40);
yi = linspace(min(y),max(y),40);
[XI,YI] = meshgrid(xi,yi);
F = TriScatteredInterp(x,y,z,'linear');
ZI = F(XI,YI);
surf(XI,YI,ZI)
\end{lstlisting}
\begin{center}
\includegraphics[width=0.6\textwidth]{figures/beispiel_scattered_data_plot}
\end{center}
\end{frame}
%
% Slide
% 
\begin{frame}[fragile]\frametitle{griddata}
\begin{lstlisting}
F = TriScatteredInterp(<x>,<y>,<z>,<methode>);
ZI = F(<XI>,<YI>);
\end{lstlisting}
\begin{itemize}
\item Vektoren $x,y,z$ enthalten Werte $(x(i),y(i),z(i))$.
\item Interpolationsstellen $(XI(i,j),YI(i,j))$ mit Matrizen \mcode{XI, YI}. 
\item Funktionsauswertung mit \mcode{F}: Ergebnis $ZI(i,j)$.
\item Art des Interpolierens:
\begin{itemize}
 \item \mcode{'nearest'}: st\"uckweise konstant
 \item \mcode{'linear'}: linear
 \item \mcode{'natural'}: natürliche Nachbarn (Voronoi-Diagramm)
\end{itemize}
\item Es wird nur innerhalb der konvexen H\"ulle der Punkte $(x(i),y(i))$
  interpoliert. Ansonsten Funktionswert \mcode{NaN}. 
\end{itemize}
\end{frame}

%
% Slide
% 
\begin{frame}[fragile]\frametitle{Bemerkungen}
\begin{itemize}
\item Der Interpolation liegt eine \alert{Delaunay} Triangulation zugrunde. Die Werte
  $(x(i),y(i))$ sind Eckpunkte der entstehenden Dreiecksmenge.
\item Danach werden mit Hilfe der Dreiecke Funktionen  definiert, die
  entsprechende Werte besitzen. 
\item Mittels \mcode{TriScatteredInterp} ist die Technik auch auf h\"ohere Dimensionen
  anwendbar. Dreiecke werden durch entsprechende höher-dimensionale
  Simplizes ersetzt. \\
(In 3D: Tetraeder)
\end{itemize}
\end{frame}
%
% Slide
% 
\begin{frame}[fragile]\frametitle{interp2}
\begin{lstlisting}
ZI = interp2(<X>,<Y>,<Z>,<XI>,<YI>,<methode>)
\end{lstlisting}
\begin{itemize}
\item Allgemein sind $X,Y,Z$ Matrizen. Dabei ist $Z(i,j)$ der Funktionswert an
  $(X(i,j),Y(i,j))$. $X$ und $Y$ sind in der Regel durch \mcode{meshgrid} erzeugt. 
\item Es wird an den Stellen $(XI(i,j),YI(i,j))$ interpoliert. Das Ergebnis
  ist $ZI(i,j)$. Die Einträge von $XI$ bzw. $YI$ k\"onnen beliebig sein. 
\item Art des Interpolierens:
\begin{itemize}
 \item \mcode{'nearest'}: st\"uckweise konstant
 \item \mcode{'linear'}: linear
 \item \mcode{'cubic'}: bikubische Splines
\end{itemize}
\end{itemize}
\end{frame}


\section{In- und Output}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Input und Output}
\begin{itemize}
\item Benutzereingabe
\item einfache und formatierte Ausgabe
\item Schreiben in Dateien
\item Einlesen von Daten aus Dateien
\item Speichern und Laden von Variablen\\
\item \alert{ \mcode{help iofun}}: Übersicht über alle Ein- und  Ausgabe - Befehle
\end{itemize}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Benutzereingabe}
\begin{itemize}
\item Standardeingabe: 
\begin{lstlisting}
input 
\end{lstlisting}
%\item Eingabe eines Zeichens:
\item Informationssteuerung durch die Maus:
\begin{lstlisting}
ginput 
\end{lstlisting}

\item Anhalten der Prozedur bis eine Tastatureingabe erfolgt: 
\begin{lstlisting}
pause
\end{lstlisting}

\end{itemize}
\end{frame} 
%
% Slide
%
\begin{frame}[fragile]\frametitle{input}
Die Benutzereingabe kann durch den Befehl \mcode{input('Text')} erfolgen. Es
wird der 'Text'  angezeigt. Die Eingabe kann hinter 'Text' erfolgen
und wird durch Return
abgeschlossen.  Durch die Option 's' wird ein String abgefragt.
  
\begin{lstlisting}
startwert = input('Bitte geben Sie den Startwert ein: ')
\end{lstlisting}
\begin{matlab}
Bitte geben Sie den Startwert ein: 56
 startwert =
     56

\end{matlab}
\begin{lstlisting}
f = input('Eingabe einer Funktion: ', 's')
\end{lstlisting}
\begin{matlab}
Eingabe einer Funktion: sin(x)*cos(x)
f =
sin(x)*cos(x)
\end{matlab}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{ginput}
Das Kommando 
\begin{lstlisting}
[x,y]=ginput(n)
\end{lstlisting}
gibt die Vektoren $x$ und $y$ der Koordinaten der nächsten $n$
Maus-Klicks zurück, an denen sich die Maus im aktuellen Grafik-Fenster
befindet.  
\begin{itemize}
\item \mcode{[x,y]=ginput} sammelt so lange Daten ein, bis die
  Return-Taste gedrückt wird.
\item \mcode{[x,y,taste]=ginput(n)} gibt auch den Vektor \mcode{taste}
  zurück, der aus Werten $1$ (linke Maustaste), $2$ (mittlere
  Maustaste) oder $3$ (rechte Maustaste) besteht. 
\end{itemize} 
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Bezier-Polynom}
\alert{ \[ z (t):=\sum_{i=0}^n {\bf b}_i B_i^n(t), \quad t \in [0,1] \]}
\begin{itemize}
\item $z(t): [0,1] \rightarrow \mathbb{R}^2$ ist das {\it Bezier-Polynom}.
\item ${\bf b}_i \in \mathbb{R}^2$ sind die vorgegebenen 
{\it Kontrollpunkte}.
\item $B_i^n(t)=\left( n \atop i \right) t^i (1-t)^{n-i}$ sind 
{\it Bernstein-Polynome}.
\end{itemize}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Bezier-Polynom}
\begin{center}\includegraphics[width=0.8\textwidth]{figures/bezier}\end{center}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Bezier-Polynom}
\lstinputlisting{bezier.m}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Ausgabe}
\begin{itemize}
\item Angeben einer Variable ohne Semicolon:
\begin{lstlisting}
text=['Pi mit 5 signifikanten Stellen : ' num2str(pi,6)]
\end{lstlisting} 
\begin{matlab} 
text =
Pi mit 5 signifikanten Stellen : 3.14159
\end{matlab} 
\item Ausgabe des Strings $X$ durch  \mcode{disp(X)}
\begin{lstlisting}
disp(text)
\end{lstlisting} 
\begin{matlab} 
Pi mit 5 signifikanten Stellen : 3.14159
\end{matlab} 
\item Ausgabe durch  \mcode{fprintf()}
\begin{lstlisting}
fprintf('Pi mit %1.0f Nachkomma-Stellen : %6.4f \n',4,pi)
\end{lstlisting} 
\begin{matlab} 
Pi mit 4 Nachkomma-Stellen : 3.1416 
\end{matlab}
\end{itemize}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{fprintf- Formartierte Ausgabe}
\begin{lstlisting}
fprintf( <Format>, <Argument1>, <Argument2>,...)
\end{lstlisting}
\textit{Format}: Output-Form der Argumente (Werte der Variablen): 
\begin{lstlisting}
'<*>%<(-|+)> <v1.n1><typ1><*>%<(-|+)> <v2.n2><typ2><*>..'
\end{lstlisting} 
\begin{description}
\item [<*>] Hier kann beliebiger Text eingegeben werden.
\item [<(-|+)>] '+': Vorzeichen-Anzeige erzwungen.\\
  '-': linksbündige Ausgabe.\\
 Weglassen von <(-|+)>: rechtsbündige Ausgabe ohne Anzeige des '+' Zeichens.
\item [v\textit{i}] Anzahl der insgesamt dargestellten Zeichen von Argument\textit{i}.
\item [n\textit{i}] Anzahl von Nachkommastellen. 
\item [typ\textit{i}] Datentyp und Darstellungsformat von Argument\textit{i}:
\begin{itemize}
 \item \alert{f} (Standarddarstellung von Gleitkommazahlen)
 \item \alert{e} (Expontialdarstellung von Gl.)
 \item \alert{g} (entweder Darst. $f$ oder $e$)
 \item \alert{s} (Strings),... 
\end{itemize}

\end{description}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Bemerkungen zu fprintf}
\begin{itemize} 
\item Die formatierte Ausgabe ist an den Ansi-C Standard angelehnt.
\item Durch \mcode{'\\n'} wird ein Zeilenumbruch bewirkt. \mcode{'\%'} erzeugt
  \mcode{\%}.
 \item \mcode{sprintf} funktioniert wie \mcode{fprintf}. Allerdings wird
  die Ausgabe als String zurückgegeben. 
\item Ist ein Argument eine Matrix, so wird fprintf 'vektorisiert'.
\end{itemize}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Schreiben in Dateien - Beispiel}
\lstinputlisting{waehrung.m}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{fopen}
\begin{lstlisting}
fid = fopen(<dateiname>, <erlaubnis>)
\end{lstlisting}

\mcode{fopen} öffnet die Datei \mcode{dateiname} im Modus
  \mcode{erlaubnis} und erzeugt einen
  Datei-Handle \mcode{fid}. Für \mcode{erlaubnis} gibt es u.a. die folgenden
  Möglichkeiten:
\begin{description}
\item ['r']  Lesen aus der Datei.
\item ['w']  Schreiben in die Datei (Erzeugen falls nötig)
\item ['a']  Hinzufügen (Erzeugen falls nötig)
\item ['r+'] Lesen und schreiben (aber nicht erzeugen) 
\end{description}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Weitere Kommandos}
\begin{itemize}
\item \mcode{fclose(fid)} schliesst die Datei mit dem Handle \mcode{fid}
\item Mit dem Befehl
\begin{lstlisting}
fprintf( <Datei-Handle>, <Format>, <Argument1>, <Argument2>,..)
\end{lstlisting}
wird in die durch das Datei-Handle angegebene Datei gemäß der obigen
Konventionen geschrieben.
\item Durch ein  zusätzliches Output-Argument können Fehler aufgefangen
  werden. 
\begin{lstlisting}
[fid, message]=fopen(<dateiname>, <erlaubnis>)
\end{lstlisting}
Ist  die Datei nicht zu öffnen, so ist \mcode{fid=-1}. 
\end{itemize}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Lesen aus einer Datei}
\lstinputlisting{waehrung_auslesen.m}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{fscanf}
\begin{lstlisting}
[daten,anz] = fscanf(<fid>,<format>,<Größe>)
\end{lstlisting}
\begin{itemize}
\item \mcode{fscanf} liest Daten aus der Datei mit dem Handle
  \mcode{fid}. 
\item Die Daten werden in \mcode{daten} gespeichert. Der optionale Wert
  \mcode{anz} gibt die Anzahl erfolgreich gelesener Daten an.
\item \mcode{format} gibt das vorgegebene Suchmuster vor.
\item Die \mcode{Größe} bestimmt das was gelesen wird, und damit auch die Dimension der Output-Matrix. \mcode{inf} bezeichnet dabei das Dateiende.
\end{itemize}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Weitere Befehle}
\begin{itemize}
\item Zeile aus der Datei mit  Handle \mcode{fid} lesen und als String zurückgeben:
\begin{lstlisting}
fgetl(fid) 
\end{lstlisting}
\item Prüfen ob das Dateiende erreicht ist:
\begin{lstlisting}
feof(fid)
\end{lstlisting}
\mcode{feof(fid)} gibt eine $1$
  zurück, falls das Dateiende erreicht ist und $0$ sonst. 
\end{itemize}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Beispiel - Bubblesort}
\begin{itemize}
\item Bubblesort durchläuft die Datenmenge von Anfang bis zum Ende und
vergleicht paarweise die nebeneinanderstehenden Elemente. 
\item Sind zwei
benachbarte Elemente nicht in der richtigen Reihenfolge, so werden sie
miteinander vertauscht. 
\item Ist man am Ende angekommen, beginnt man wieder
von vorne. 
\item Die Datenmenge ist sortiert, falls bei einem Durchlauf
keine Vertauschungen mehr vorgenommen werden.
\end{itemize} 
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Beispiel - Bubblesort}
\begin{lstlisting}
 function sortieren(dateiname1, dateiname2)
% sortieren   Die Datei dateiname1 wird alphabetisch sortiert
%             und als dateiname2 abgespeichert.
%   INPUT:    STRING dateiname1
%             STRING dateiname2
 
% Datei laden
[fid,message] = fopen(dateiname1,'r');
if fid==-1 
    error('Datei nicht gefunden');
end;
% Datei lesen
anz = 0;
while feof(fid)==0
    anz = anz+1;     
    inhalt{anz}=fgetl(fid); 
end
fclose(fid);
\end{lstlisting}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Beispiel - Bubblesort (Forts.)}
\begin{lstlisting}
% Sortieren
sortierungen = 1; 
while sortierungen>0
    sortierungen = 0;
    for k = 1:anz-1
        % vergleich_gr(a,b) ist 1 fuer a<b, 0 sonst
        if vergleich_gr(inhalt{k+1},inhalt{k})
            hilf = inhalt{k}; inhalt{k} = inhalt{k+1}; 
            inhalt{k+1} = hilf;
            sortierungen = sortierungen+1;
        end
    end
end
% Datei schreiben
fid = fopen(dateiname2,'w');
for k = 1:anz
   fprintf(fid,'%s \n',inhalt{k}); 
end;
fclose(fid);
\end{lstlisting}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Bemerkungen}
\begin{itemize}
\item Es ist auch möglich temporäre Dateien zu erzeugen.
\item Binäre Dateien: \alert{\mcode{fread}} und \alert{\mcode{fwrite}}. 
\item Excel-Tabellen esen: \alert{\mcode{xlsread}} 
\item Bilddateien importieren: \alert{\mcode{imread}}.
\item Audiodateien (.wav) bzw. Videodateien (.avi):
 \alert{\mcode{wavread}} bzw. \alert{\mcode{aviread}}. 
\end{itemize}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Beispiel: Bin\"are Daten}
\begin{lstlisting}
%-------------------- beispiel_bin_data.m
A = hilb(10);

% Schreibe binaere Datei
fwriteid = fopen('hilb10.bin','w');
count = fwrite(fwriteid,A,'double');
fclose = (fwriteid);

% Lesen binaere Datei
freadid = fopen('hilb10.bin','r');
B = fread(freadid, count, 'double');
C = reshape(B,10,10);

disp(norm(A - C))
\end{lstlisting}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Laden und Speichern von  Variablen}
\begin{itemize}
\item \alert{ \mcode{save filename}} speichert den gesamten
  Workspace in der Datei \mcode{filename.mat}. Einladen des Workspace
  ist möglich mittels  \alert{ \mcode{load filename}}. 
\item Mittels \alert{ \mcode{save filename A x}} werden nur die
  Variablen $A$ und $x$ in der Datei \mcode{filename.mat}
  gespeichert. Durch  \alert{ \mcode{load filename}} werden nun die
  Variablen $A$ und $x$ dem Workspace hinzugefügt. 
\item Bei \mcode{load} werden bestehende Variablen mit dem gleichen
  Namen überschrieben.
\end{itemize}
\end{frame}

\section{Etwas Debugging}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Fehler-Arten}
% In MATLAB gibt es zwei Arten von Fehler.
\begin{itemize}
\item \alert{ Syntax Fehler}: z.B. Schreibfehler oder
  Weglassen von Klammern. MATLAB entdeckt die meisten Syntax Fehler
  und gibt eine entsprechende Fehlermeldung zurück mit Angabe der
  Zeile. 
\item \alert{ Run-time Fehler}: Diese Fehler sind
  normalerweise algorithmischer Natur. Oft passen z.B. bei
  Matrixoperationen die Matrizen nicht zusammen.
\end{itemize}

\scriptsize{ Die erste Fehlermeldung zeigt bei geschachtelten Funktionsaufrufen
an, in welcher Funktion der Fehler liegt.}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Fehler abfangen}
\begin{itemize}
\item \alert{Fehlermeldungen}
\begin{lstlisting}
error(<text>) 
\end{lstlisting}
Bricht das Programm ab. Insbesondere die Eingabeparameter sollten auf Fehler geprüft werden.
\item \alert{Warnungen}
\begin{lstlisting}
warning(<text>)
\end{lstlisting}
Programm wird fortgesetzt.
\end{itemize}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Beispiel}
\begin{lstlisting}
function interpolation(f1,N)
\end{lstlisting}
\alert{ \centering{$\cdots$}}\\
\begin{lstlisting}
%----------------- Fehlerbehandlung
if (round(abs(N)) ~= N) | (N==0)
    error(strcat('Bitte fuer die Anzahl der Stuetzstellen',...
    'eine natuerliche Zahl verwenden'));
end
if ~ischar(f1)
    error('Bitte fuer die Funktion einen String verwenden');
end
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]\frametitle{Integrierter Debugger}
\begin{itemize}
 \item \alert{Breakpoints}: Halten das Programm an der Gegebenen Stelle an. Aktivierung: Klick in der linken Spalte rechtes neben der Zeilennummer. 
 \item \alert{Debug-Modus}: Menu: Debug->Stop if Errors/Warnings auf \textit{always stop if error} setzen.
 \item \alert{Step} (F10) Ein Schritt weiter im gegebenen Kontext.
 \item \alert{Step in} (F11) Ein Schritt weiter im gegebenen Kontext. Wechselt zu aufgerufenen Funktionen. 
\item \alert{continue} (F5) Führt das Programm normal fort.
\end{itemize}

\end{frame}





\end{document}

