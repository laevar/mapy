\documentclass[hyperref={dvipdfmx,pdfpagelabels=false}]{beamer}
\title{Einführung in Matlab - Einheit 5}
\subtitle{Mehrdimensionale Arrays, Funktionen, Numerische lineare Algebra, Dünnbesetzte Matrizen}
\input{../slide_header}
\maketitle

\section{Mehrdimensionale Arrays}
%
%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Mehrdimensionale Arrays}
\begin{itemize}
\item mehrdimensionale Arrays (Dim. > 2).
\begin{lstlisting}
A(:,:,1) = ones(3);
A(:,:,2) = 2*ones(3);
whos
\end{lstlisting}
\begin{matlab}
  Name   Size   Bytes  Class  
  A      3x3x2    144  double  
\end{matlab}
\item \alert{ \mcode{cat(<dim>,<A1>,<A2>,..)}} f\"ugt die Arrays \mcode{A1},
  \mcode{A2},.. entlang der Dimension \mcode{dim} zusammen. 
\begin{lstlisting}
 A = cat(3,ones(3), 2*ones(3))
\end{lstlisting}
\item Befehle wie \alert{ \mcode{zeros}}, \alert{ \mcode{ones}} oder \alert{
  \mcode{repmat}} funktionieren auch im multidimensionalen Kontext.
\end{itemize}
\end{frame}
%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Umsortieren von Arrays}
\begin{lstlisting}
reshape(X,n1,..,ns)
\end{lstlisting}
Der Befehl liest $X$ spaltenweise
aus, und schreibt die Elemente spaltenweise in ein $(n_1, \dots,
n_s)$-Array. 
\begin{itemize}
\item $X$ muss $n_1 \cdots n_s$ Elemente enthalten.
\item Der Befehl ist sehr n\"utzlich.
\end{itemize}
\textbf{Beispiele:}
\begin{lstlisting}
reshape(hilb(4), 8,2)
reshape(hilb(4), 4,2,2)
\end{lstlisting}
\end{frame}
%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Zugriff auf mehrdim. Arrays}
Intern werden Arrays als Spalten abgespeichert. Zugriff durch linearen
  Index m\"oglich. 
\begin{lstlisting}
B = reshape(1:12,2,3,2)
\end{lstlisting}
\begin{matlab}
B(:,:,1) =
     1     3     5
     2     4     6
B(:,:,2) =

     7     9    11
     8    10    12
\end{matlab}
\begin{lstlisting}
B(7:9)
\end{lstlisting}
\begin{matlab}
ans =
     7     8     9
\end{matlab}
\end{frame}
%
% Slide
% 
\begin{frame}[fragile]\frametitle{N\"utzliche Befehle}
\begin{itemize}
\item Anzahl der Dimensionen von $X$: 
\begin{lstlisting}
ndims(X) 
\end{lstlisting}
\item Gr\"o{\ss}e von $X$: 
\begin{lstlisting}
size(X)
\end{lstlisting}
\item Umwandlung von linearer Indizierung in Array-Indizierung: 
\begin{lstlisting}
ind2sub
\end{lstlisting}
\item Umwandlung von Array-Indizierung in lineare Indizierung:
 \begin{lstlisting}
sub2ind
\end{lstlisting}
\begin{lstlisting}
A = reshape(1:12,2,3,2);
A(ind2sub(size(A),5))
\end{lstlisting}
\begin{matlab}
ans =
     5
\end{matlab}
\item Man kann auch mit mehrdimensionalen Arrays rechnen.
\end{itemize}

\end{frame}
%



\section{Vertiefung Funktionen}

%
% Slide
%
\begin{frame}[fragile]\frametitle{Funktionen}
\begin{itemize}
 \item Funktions-Typen
\begin{itemize}
\item m.-File
\item inline
\item anonyme
\item string
\end{itemize}
\item Funktionen werden in einem eigenen {\it Workspace} verwaltet.
\item Beim ersten Aufruf speichert MATLAB die Funktion im Workspace bis MATLAB
  verlassen wird oder die Funktion \mcode{fun} mit  \mcode{clear fun} gel\"oscht wird.
\item Namen: Buchstaben mit 1-63 Zeichen (Ohne -,+,*,/ !). 
\end{itemize}
\end{frame}

%
% Slide
%
\begin{frame}[fragile]\frametitle{Function-Handles}

Ein {\it Function Handle} ist ein MATLAB Datentyp, das alle Informationen
enth\"alt, die zur Auswertung einer Funktion n\"otig sind.\\
\begin{itemize}
\item Definition, z.B. 
\begin{lstlisting}
Sinus = @sin 
\end{lstlisting}
\item Anwendung bei der \"Ubergabe von Funktionen:
\begin{lstlisting}
quad(Sinus,0,1)
\end{lstlisting}
\item m-File Funktionen haben ihren Namen als Handle ( \mcode{@func_name} für \mcode{func_name.m})
% \item Anonyme Funktion: 
% \begin{lstlisting}
%  f = @(x) sin(x)*cos(x)
% \end{lstlisting}
\end{itemize}
\end{frame}


\subsection{Ein-/Ausgabe - Parameter}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Ein-/Ausgabe - Parameter} 
\begin{itemize}
 \item Eingabeparameter als Cell-Array
\begin{lstlisting}
varargin
\end{lstlisting}
\item Die Anzahl der Inputvariablen
\begin{lstlisting}
nargin
\end{lstlisting}
\item Cell-Array der Ausgabewerte
\begin{lstlisting}
varargout
\end{lstlisting}
\item Die Anzahl der Outputvariablen
\begin{lstlisting}
nargout
\end{lstlisting}
\end{itemize}

\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Beispiel: varargin}
\begin{lstlisting}
function result = integral(varargin)
% berechnet approximativ ein Integral ueber (a,b) 
% durch die Mittelpunktregel mit Hilfe von N Punkten
% Eingabe: 0 Parameter:       (N=20, a=0, b=1)
%          1 Parameter: N     (a=0,b=1)
%          3 Parameter: N,a,b
% Jochen Schulz		16.08.2009
N = 20; a = 0; b = 1; % Default-Einstellung
anzahl_parameter = nargin; % Anz. Input-argumente
if anzahl_parameter == 1 
    N = varargin{1};
end
if anzahl_parameter == 3
    N = varargin{1}; a = varargin{2}; 
    b = varargin{3};
end
if anzahl_parameter ~= [0 1 3]
    error('Falsche Anzahl an Input-Argumenten');
end
\end{lstlisting}
\end{frame}
\begin{frame}[fragile]\frametitle{Beispiel: varargin}
\begin{lstlisting}
x = (a+(b-a)/(2*N)):(b-a)/N:(b-(b-a)/(2*N));
y = x.^3;
% Berechnung des Integrals
result = (b-a)*sum(y)*(1/N);

close all; % Plot
x1 = linspace(a,b,N+1);
for i = 1:N
    fill([x1(i) x1(i)  x1(i+1) x1(i+1)], [0 y(i)  y(i) 0], 'r');
    hold on;
end
plot(a:(b-a)/100:b,(a:(b-a)/100:b).^3,'LineWidth',3);
title(strcat('\int x^3 = ',num2str(result),...
' fuer N =', num2str(N))); 
\end{lstlisting}
\end{frame}


\subsection{Funktionen-Typen}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Anonyme Funktion}
\begin{lstlisting}
 @(<x>) <funktion(x)>
\end{lstlisting}

\begin{itemize}
\item Funktion mit Parameter
\begin{lstlisting}
y = 1; f = @(x) sin(x)./(x+y) ;
f(2)
\end{lstlisting}
\begin{matlab}
ans =
    0.3031
\end{matlab}

\item Gamma-Funktion $\Gamma(s) = \int_0^\infty x^{s-1} e^{-x} dx$.
\begin{lstlisting}
k = @(s) quad( @(x) x.^(s-1).*exp(-x),0.1,500) ;
k(4),k(5)
\end{lstlisting}
\begin{matlab}
ans =
    6.0000
ans =
   24.0000
\end{matlab}

\end{itemize}
\end{frame}

%
% Slide
%
\begin{frame}[fragile]\frametitle{String-Funktionen}
\begin{lstlisting}
<fun> = '<funktions-string>' 
\end{lstlisting}

\begin{itemize}
\item Eingabe als String: 
\begin{lstlisting}
a = 'exp(z)-1+z'
\end{lstlisting}
\item Plotten der zugeh\"origen Funktion 
\begin{lstlisting}
ezplot(a,[-1 1]) 
\end{lstlisting}
%\item Konvertieren zwischen Strings und Funktionen: \alert{
%  \mcode{str2func}}, \alert{ \mcode{func2str}} 
\end{itemize}
\alert{Bemerkung:} \\
Funktionen gegeben als Strings sind im allgemeinen zu vermeiden!
Besser andere Konstrukte (wie Inline-Funktionen) benutzen!
\end{frame}



%
% Slide
%
\begin{frame}[fragile]\frametitle{Inline-Funktionen}
\begin{lstlisting}
<fun> =  inline('<funktions-string>')
\end{lstlisting}

\textbf{Beispiele:} \\
\begin{columns}[t]
 \column{0.48\textwidth}
\begin{lstlisting}
a = 'exp(z) - 1 + z'; 
f = inline(a)
\end{lstlisting}
\begin{matlab}
f =
     Inline function:
     f(z) = exp(z)-1+z
\end{matlab}
\begin{lstlisting}
g = inline('x+y^2','x','y')
\end{lstlisting}
\begin{matlab}
g =
     Inline function:
     g(x,y) = x+y^2
\end{matlab}
\column{0.48\textwidth}
\begin{lstlisting}
f(1),g(1,2),a(2)
\end{lstlisting}
\begin{matlab}
ans =
    2.7183
ans =
     5
ans =
     x
\end{matlab}
\end{columns}
\end{frame}

\subsection{Umgang und Beispiele}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Befehle f\"ur Funktionen}
\begin{itemize}
\item Auswertung der Funktion  \mcode{fun} an der Stelle $(x1,..,xn)$. 
\begin{lstlisting}
feval(<fun>,<x1>,..,<xn>)
\end{lstlisting}
\mcode{fun} ist dabei
  entweder ein Funktionsname oder ein Function-Handle. 
\item Wandlung eines Strings \mcode{g} in eine Inline-Funktion (vgl. \mcode{inline}). 
\begin{lstlisting}
f = fcnchk(<g>) 
\end{lstlisting}
Ist \mcode{g} ein
  Function-Handle oder eine Inline-Funktion so ist $f = g$.  

\item Strings oder Inline-Funktionen \mcode{f} \textsl{vektorisieren}
\begin{lstlisting}
vectorize(<f>)
\end{lstlisting}
d.h. \mcode{'*'} $\Rightarrow$ \mcode{'.*'} , \mcode{'^'} $\Rightarrow$ \mcode{'.^'}, usw. 

\end{itemize}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Beispiel: integral2.m (Auszug)}
\begin{lstlisting}
function result = integral2(varargin)
% Eingabe: 1 Parameter: f       (N=20, a=0, b=1)
%          2 Parameter: f,N     (a=0,b=1)
%          4 Parameter: f,N,a,b
N = 20; a = 0; b = 1; % Default-Einstellung
anzahl_parameter = nargin; % Anz. Input-argumente
if anzahl_parameter == 2 
    N = varargin{2};
end;
if anzahl_parameter == 4
    N = varargin{2}; a = varargin{3}; b = varargin{4};
end;
if anzahl_parameter ~= [1 2 4]
    error('Falsche Anzahl an Input-Argumenten');
end;
% eventuelle Umwandlung von Strings
f = fcnchk(varargin{1},'vectorized'); 
x = (a+(b-a)/(2*N)):(b-a)/N:(b-(b-a)/(2*N));
y = feval(f,x);  
\end{lstlisting}
\end{frame}
% 
% Slide
% 
\begin{frame}[fragile]\frametitle{}
\centering\alert{ \mcode{integral2('log(x.^2)',30,1,5)}}\\
\begin{center}\includegraphics[width=0.8\textwidth]{./figures/plot_log}\end{center} 
\end{frame}



%
% Slide
%
\begin{frame}[fragile]\frametitle{Beispiel: Sobolevsche Mittelungsfunktion}
\alert{ \[ f(x) := \left \{ \begin{array}{ll} \exp(- \frac{1}{1-\|x\|^2}), &
\|x \| <1 \\ 0, & \|x \| \geq 1 
\end{array} \right .  
\]}
mit $\|x\|^2:=\sum_{i=1}^N x_i^2$, $x=(x_1, \dots x_N) \in
\mathbb{R}^N$.\\[0.5cm]

2 Versionen:
\begin{itemize}
\item eindimensionale Version
\item N-dimensionale Version
\end{itemize}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{1d-Fall}
\lstinputlisting{f_1d.m}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{n-dimensionaler-Fall}
\begin{lstlisting}
function result = f(varargin)
% f.m     Sobolevsche Mittelungsfunktion
%         Eingabe: Matrizen x1,x2,x3,..
%         Ausgabe: Matrix result=f(x1,x2,...)
betrag = varargin{1}.^2;
for i = 2:nargin
  betrag = betrag+varargin{i}.^2;
end
dimension = size(varargin{1});
result = zeros(dimension(1),dimension(2));
for j = 1:dimension(1)
  for k = 1:dimension(2)
    if betrag(j,k) < 1
      result(j,k) = exp(-1/(1-betrag(j,k)));
    else
      result(j,k) = 0;
    end;
  end;
end;
\end{lstlisting}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Programm zum Plotten}
\begin{lstlisting}
%    plot_f.m

% Eindimensionaler Plot
subplot(2,2,1),
ezplot(@f);

% Zweidimensionaler Plot
subplot(2,2,2),
ezmesh(@f);

% Zweidimensionaler Plot
subplot(2,2,3),
ezsurfc(@f);

% Zweidimensionaler Plot
subplot(2,2,4),
ezcontourf(@f);
\end{lstlisting}
\end{frame}
\begin{frame}[fragile]\frametitle{Plots der Funktion}
\begin{center}
\includegraphics[width=0.8\textwidth]{./figures/plot_f}  
\end{center}
\end{frame}

% 
% Slide
% 
\begin{frame}[fragile]\frametitle{}
\centering\alert{ \mcode{integral2(@f,50,-1.1,1.1)}}\\
\begin{center}
\includegraphics[width=0.8\textwidth]{./figures/plot_sobolev} 
\end{center}
\end{frame}



\section{Numerische Lineare Algebra}

\subsection{Normen}
% 
% Slide
%
\begin{frame}[fragile]\frametitle{Vektornorm}
Die $p$-Norm eines Vektors $x=(x_1, {} \dots , x_n)$
\[ \|x \|_p := \left( \sum_{i=1}^n  |x_i|^p \right)^{1/p} \] 
(definiert für $p\geq 1$).
\begin{itemize}
\item in MATLAB: \mcode{norm(x,p)} (Default: $p=2$) 
\item $p=\infty$ entspricht der Maximum-Norm 
\[  \|x \|_\infty = \max_{i=1, \dots n} |x_i|. \]
\end{itemize}
\end{frame}
% 
% Slide
%
\begin{frame}[fragile]\frametitle{Matrixnorm}
Seien  $A\in \mathbb{C}^{n \times m}$ und
$p \geq 1$. Die
{\it Matrixnorm} ist definiert durch
\[ \| A \|_p = \sup_{x\in \mathbb{C}^m \setminus \{ 0 \}} \frac{\|Ax
  \|_p}{\| x \|_p}. \]
\begin{itemize}
\item In MATLAB: \mcode{norm(A,p)} (Default $p=2$).
\item $p=\infty$ kann charakterisiert werden durch
\[ \|A\|_\infty = \max_{1 \leq j \leq m} \sum_{i=1}^n |a_{ij}|, \quad
\mbox{Zeilensummennorm.} \]
\end{itemize} 
\end{frame}
% 
% Slide
%
\begin{frame}[fragile]\frametitle{Kondition}
Kondition einer quadratischen Matrix $A$: 
{ \[ \cond_p(A):=\|A\|_p\|A^{-1}\|_p. \] }
\vspace*{-0.8cm}
\begin{itemize}
\item In MATLAB: 
  \mcode{cond(A,p)} (Default $p=2$) 
\item Es gilt $\cond_p(A)\geq 1$.
\item Die Kondition mißt die Empfindlichkeit der Lösung $x$ von $Ax=b$
  gegenüber  Störungen
  von $A$ und $b$.
\item Ist $\cond_p(A) >> 1$, so ist die Matrix beinahe singulär. Die Matrix ist {\it schlecht konditioniert}.
\end{itemize}
\end{frame}
% 
% Slide
%
\begin{frame}[fragile]\frametitle{Beispiele}
\begin{itemize}
\item Vektornormen für $x=(1/100) (1, 2, \dots, 100)$
\begin{lstlisting}
>> x = (1:100)/100; [norm(x,1) norm(x,2) norm(x,inf)]
ans =   50.5000    5.8168    1.0000
\end{lstlisting}
\item Matrixnorm für die Hilbert-Matrix $H=(\frac{1}{i+j-1})_{ij}$
\begin{lstlisting}
>> H = hilb(10); [norm(H,1) norm(H,2) norm(H,inf)]
ans =    2.9290    1.7519    2.9290
\end{lstlisting}
\item Kondition der Hilbert-Matrix
\begin{lstlisting}
>> H = hilb(10); [cond(H,1) cond(H,2) cond(H,inf)]
ans =
   1.0e+13 *
    3.5354    1.6025    3.5354
\end{lstlisting}
\end{itemize}
\end{frame}

\subsection{Lösen linearer Gleichungssyteme}
% 
% Slide 
%
\begin{frame}[fragile]\frametitle{Lineare Gleichungssysteme}
Seien $A \in \mathbb{C}^{n\times n}$ und $b \in \mathbb{C}^n$. Das
lineare Gleichungssystem 
{ \[ A x=b \]}
wird in MATLAB gelöst durch  \mcode{ x=A\\b}.\\

\begin{lstlisting}
>> x = ones(5,1); H = hilb(5); b = H*x; y = (H\b)'
y =
    1.0000    1.0000    1.0000    1.0000    1.0000
\end{lstlisting}

\alert{Warnung:} Benutze nie
\mcode{x=inv(A)*b}, da das Berechnen von $A^{-1}$ sehr aufwendig sein kann.
\end{frame}
% 
% Slide 
%
\begin{frame}[fragile]\frametitle{LU-Zerlegung}
{\centering  Was bedeutet \mcode{A\\b}?}\\[0.5cm]

MATLAB berechnet die LU-Zerlegung von $A$ (Gaussverfahren):
\begin{itemize}
 \item obere Dreiecksmatrix $U$
 \item untere Dreiecksmatrix $L$ mit Einsen auf der Diagonalen
\end{itemize}
so dass $PA=LU$ gilt ($P$ Permutationsmatrix).

Dann wird das LGS durch Rückwärts- und Vorwärtseinsetzen gelöst
($Lz = Pb$, $Ux = z$)

\begin{lstlisting}
>> [L,U,P]=lu(hilb(5)); norm(P*hilb(5)-L*U)
ans =  2.7756e-17
\end{lstlisting}
\end{frame}
% 
% Slide 
%
\begin{frame}[fragile]\frametitle{Inverse,  Determinante}
\begin{itemize}
\item Berechnung der Inversen
\begin{columns}[onlytextwidth]
\column{0.45\textwidth}
\begin{lstlisting}
>> A=pascal(3)
A =
     1     1     1
     1     2     3
     1     3     6
\end{lstlisting}
\column{0.45\textwidth}
\begin{lstlisting}
>> X=inv(A)
X =
     3    -3     1
    -3     5    -2
     1    -2     1
\end{lstlisting}
\end{columns}
\item Berechnung der Determinante
\begin{lstlisting}
>> det(A)
ans = 1
\end{lstlisting}
\end{itemize}
\end{frame}
% 
% Slide 
%
\begin{frame}[fragile]\frametitle{Pseudoinverse}
\begin{block}{(Moore-Penrose) Pseudoinverse}
Sei $A$ singulär, Bestimme $X$ so dass 
\[ A X A=A,  X A X =X,  (X A)^* =X A,  (A X )^* = A X \]
\end{block}
\begin{lstlisting}
>> pinv(ones(3,3))
ans =
    0.1111    0.1111    0.1111
    0.1111    0.1111    0.1111
    0.1111    0.1111    0.1111
\end{lstlisting}
\end{frame}

\subsection{Anwendung: Zwei-Punkt-Randwert-Aufgabe}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Zwei-Punkt-Randwert-Aufgabe}

Suche eine Funktion 
\begin{equation*}
u:[0,1] \quad \rightarrow \quad \mathbb{R}, 
\end{equation*}
so dass 
\begin{eqnarray*}
-u''(x) & = & e^x, \quad x \in (0,1)\\
u(0) & = & u(1) =0
\end{eqnarray*}
\alert{Problem:} Es kann i.A. keine geschlossene
Lösungsdarstellung angegeben werden. \\ %Wieso ?

\alert{Ausweg:} Approximation der Lösung. 
\end{frame}
%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Finite Differenzen Verfahren}

Diskretisierung: $0=x_0 < \dots < x_{n}=1$ mit $x_i=\frac{i}{n}$\\

Differenzenquotient: 
\[ u''(x_i) \sim \frac{u(x_{i-1}) - 2 u(x_i) + u(x_{i+1})}{ 
  h^2}, \quad h:=\frac{1}{n} \]

Einsetzen in $-u''(x)=e^x$ ergibt 
\[ -u(x_{i-1}) + 2 u(x_i) - u(x_{i+1}) =  h^2 e^{x_i}, \quad
i=1,\dots ,n-1 \] 
Randbedingungen $\Rightarrow $ $u(x_0)=u(x_n)=0$.\\

$\Rightarrow$ Lineares Gleichungssystem für 
$u(x_1), \dots ,u(x_{n-1})$.
\end{frame}

%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Diskretes Problem}

Setze $z=(z_1,\dots ,z_{n-1})^t=(u(x_1), \dots ,u(x_{n-1}))^t$. \\

Löse das Gleichungssystem  $Az=F$  mit 
\[ A:= 
\left( \begin{array} {ccccccc}
 2 & -1 &  & &   0 \\
-1 & 2  & -1 &    & \\ 
   & \ddots & \ddots & \ddots   &\\
   & &  -1 & 2  & -1  \\ 
0 &  &    & -1 & 2 \\
\end{array} \right), \  F:=
h^2 \left( \begin{array}{c} e^\frac{1}{n}\\   \vdots \\ e^\frac{n-1}{n}
\end{array} \right) .
\] 
\end{frame}
%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Lösung für $n=21$}
\begin{itemize}
\item Zerlegung des Intervalls $[0,1]$
\begin{lstlisting}
x = 0:(1/21):1
\end{lstlisting}
\item Eleminieren der Randpunkte
\begin{lstlisting}
x_i = x(2:21)
\end{lstlisting}
\item Erzeugen der Matrix $A$ (Übungsaufgabe)
\end{itemize}
\end{frame}
%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Lösung für $n=21$}
\begin{itemize}
\item Berechnen der rechten Seite:
\begin{lstlisting}
F = (1/21)^2*transpose(exp(x_i));
\end{lstlisting}
\item Lösen des linearen Gls.\\
\begin{lstlisting}
z_i = A\F;
\end{lstlisting}
\item Zufügen der Werte am Rand
\begin{lstlisting}
>> z = [0; z_i;0];
\end{lstlisting}
\end{itemize}
\end{frame}
%
% Slide: 
%
\begin{frame}[fragile]\frametitle{Lösung für $n=21$}
\begin{columns}[c]
\column{0.48\textwidth}
\begin{lstlisting}[basicstyle=\tiny]
plot(x,z,'r*','MarkerSize',8)
\end{lstlisting}
\includegraphics[width=\textwidth]{figures/bild1_27_10}

\column{0.48\textwidth}
\begin{lstlisting}[basicstyle=\tiny]
plot(x,z,'r*-','LineWidth',3,'MarkerSize',8)
\end{lstlisting}%
\includegraphics[width=\textwidth]{figures/bild2_27_10}
\end{columns}
\end{frame}


\subsection{Bestimmung von Eigenwerten}
% 
% Slide 
%
\begin{frame}[fragile]\frametitle{Eigenwerte}
\begin{block}{Eigenwert}
Sei $A \in \mathbb{C}^{n \times n}$. $\lambda \in \mathbb{C}$ ist
Eigenwert von $A$, falls ein Vektor $x \in \mathbb{C}^n$ ungleich $0$ existiert, so
dass  $Ax = \lambda x$ gilt. $x$ heißt Eigenvektor.  
\end{block}

\begin{itemize}
\item {}\mcode{x=eig(A)}\\ berechnet die Eigenwerte von $A$ und schreibt
  sie in den Vektor $x$.
\item
  {}\mcode{[V,D]=eig(A)}\\
  $D$ ist eine Diagonalmatrix mit den Eigenwerten auf der
  Diagonalen. Die Spalten von $V$ bilden die zugehörigen Eigenvektoren. 
\end{itemize}
\end{frame}
% 
% Slide 
%
\begin{frame}[fragile]\frametitle{Weitere Zerlegungen}
\begin{itemize}
\item \alert{QR-Zerlegung}: \mcode{[Q,R]=qr(A)}\\
  $m \times n$- Matrix $A$ eine Zerlegung { $A=QR$} erzeugt,
  ($Q$ eine unitäre $m \times m$-Matrix, $R$ eine obere $m \times n$ Dreiecksmatrix).
%Die QR-Zerlegung spielt in vielen Verfahren der numerischen Mathematik  eine wichtige Rolle, 
%beispielsweise um eine orthogonale oder unitäre Basis zu bestimmen oder um lineare Ausgleichsprobleme 
%zu behandeln. 
%QR-Algorithmus zur Berechnung aller Eigenwerte einer Matrix.
\item \alert{Singulärwertzerlegung}: \mcode{[U,S,V]=svd(A)}\\
  { $A=U \Sigma V^*$}. 
  ($\Sigma \subset \mathbb{C}^{m \times n}$ eine Diagonalmatrix \\
  $U \subset \mathbb{C}^{m \times m}$, $V \subset  \mathbb{C}^{n \times n}$ unitäre Matrizen). 
%Dieses Verfahren wird insbesondere in der numerischen Mathematik verwendet. Dort lassen sich beispielsweise quasisinguläre 
%lineare Gleichungssysteme im Rahmen rechentechnischer Genauigkeiten passabel lösen.
%In der Statistik ist die SVD der rechnerische Kern der Hauptkomponentenanalyse, dort auch Karhunen-Loève-Transformation genannt.
%Einige moderne Bildkompressionsverfahren beruhen auf einem Algorithmus, der das Bild (=Matrix aus Farbwerten) in eine SVD überführt 
%und anschließend nur die stark von null verschieden Elemente der Matrix Σ berücksichtigt und dann die zur Rückgewinnung der Matrix 
%erforderlichen Vektoren sowie die verbliebenen Diagonalelemente speichert. Besonders effektiv ist diese Kompression bei 
%bestimmten rechteckigen Mustern und natürlich, je größer (und je quadratischer) das Bild ist. Dies ist eine mögliche Anwendung 
%von Modellreduktion. Das Weglassen von kleinen Singulärwerten ist ein verlustbehaftetes Modellreduktionsverfahren.

\item \alert{Cholesky-Zerlegung}: \mcode{R=chol(A)}\\
  { $A=R^*R$} zu einer hermiteschen, positiv definiten Matrix
  $A$ ($R$ ist eine obere Dreiecksmatrix mit reellen, positiven
  Diagonalelementen). 
\end{itemize}
%Eine Matrix A heißt hermitesch (nach Charles Hermite) oder selbstadjungiert genau dann, wenn sie gleich ihrer 
%(hermitesch) Adjungierten A * , also gleich der transponierten und komplex konjugierten Matrix ist. D. h.

%positiv definit, 	falls x^T Ax > 0

%Die Cholesky-Zerlegung kann auch zur Gewinnung eines Vorkonditionierungsverfahrens für lineare Gleichungssysteme mit 
%positiv definiter Matrix benutzt werden; zu diesem Zweck gibt es speziell die Variante der unvollständigen Cholesky-Zerlegung 
%sowie der modifizierten unvollständigen Cholesky-Zerlegung.
% determinante
% test ob es eine positiv definite matrix ist
\end{frame}
% 
% Slide 
%
\begin{frame}[fragile]\frametitle{Bemerkungen}
\begin{itemize}
\item LGS können auch mit Hilfe iterativer Verfahren gelöst werden,
  z.B. \mcode{gmres}, \mcode{pcg}, \mcode{bicgstab}.
\item $A\in \mathbb{C}^{n \times m}$, $n \neq m$ bei \mcode{A\\b}:
\begin{itemize}
\item $n>m$ (überbestimmter Fall): Least-Square Lösung, d.h. der Ausdruck
  \mcode{norm(A*x-b)} wird minimiert. 
\item $n<m$ (unterbestimmter Fall): Grundlösung. 
\end{itemize}
\end{itemize}
\end{frame}


\section{D\"unnbesetzte Matrizen}

% 
% Slide 
%
\begin{frame}[fragile]\frametitle{D\"unnbesetzte Matrizen}
\begin{itemize}
\item Bei {\it D\"unnbesetzten Matrizen} ({\it sparse matrices}) sind
  fast alle Eintr\"age $0$.
\item In vielen Anwendungen, z.B. bei der Diskretisierung von
  Differentialgleichungen oder in der Graphentheorie, treten sehr
  grosse, d\"unnbesetzte  Matrizen auf.
\item In MATLAB steht daf\"ur ein eigener Datentyp zur Verf\"ugung, der zu
  jedem Nichtnullelement der Matrix, die zugeh\"orige Zeile und Spalte
  speichert.    
\end{itemize}
\end{frame}
% 
% Slide 
%
\begin{frame}[fragile]\frametitle{Beispiel}
\begin{lstlisting}
A = 2*diag(ones(10,1),0) ...
       - diag(ones(9,1),-1) ...
       - diag(ones(9,1),1);
B = sparse(A)
\end{lstlisting}
\begin{matlab}
B =   (1,1)        2
      (2,1)       -1
      (1,2)       -1
      (2,2)        2
\end{matlab}
\begin{lstlisting}
C = 2*diag(ones(100,1),0) ...
       - diag(ones(99,1),-1) ...
       - diag(ones(99,1),1);
D = sparse(C); whos
\end{lstlisting}
\begin{matlab}
  Name      Size           Bytes  Class
  A        10x10             800  double array
  B        10x10             380  sparse array
  C       100x100          80000  double array
  D       100x100           3980  sparse array
\end{matlab}
\end{frame}
% 
% Slide 
%
\begin{frame}[fragile]\frametitle{Einige Befehle}
\begin{itemize}
\item Erzeugung einer d\"unnbesetzten Matrix
  der Gr\"osse $n \times m$. Alle Eintr\"age sind $0$.
\begin{lstlisting}
sparse(n,m) 
\end{lstlisting}

\item Konvertierung der dichtbesetzten Matrix
  $A$ in eine d\"unnbesetzte Matrix.
\begin{lstlisting}
sparse(A)
\end{lstlisting}

\item Die Struktur der Matrix $A$ visualisieren.
\begin{lstlisting}
spy(A)
\end{lstlisting}

\item Die meisten Standardoperationen funktionieren auch mit
  d\"unnbesetzten Matrizen.  
\end{itemize}
\end{frame}
% 
% Slide 
%
\begin{frame}[fragile]\frametitle{Dichte und d\"unnbesetzte Matrizen}
\begin{itemize}
\item Konvertierung der d\"unnbesetzten Matrix $A$ in eine dichtbesetzte Matrix $B$ .
\begin{lstlisting}
B = full(A)
\end{lstlisting}
\item Bei bin\"aren Operationen, z.B. $A+B$ oder $A*B$ ist das Ergebnis
  bei d\"unnbesetzten Matrizen $A$ und $B$ wieder eine d\"unnbesetzte
  Matrix. \\Ist eine der Matrizen dichtbesetzt, so ist auch das Ergebnis
  dichtbesetzt. 
\item Berechnung der $k$ betragsm\"a{\ss}ig  gr\"ossten Eigenwerte (Default: $k=6$):
\begin{lstlisting}
eigs(A,k) 
\end{lstlisting}

\end{itemize}
\end{frame}
% 
% Slide 
%
\begin{frame}[fragile]\frametitle{D\"unnbesetzte Matrizen}
\begin{itemize}
\item Norm- und Konditionsberechnung:
\begin{lstlisting}
normest(<A>) , condest(<A>)
\end{lstlisting}

\item Alle iterativen Verfahren funktionieren auch mit d\"unnbesetzten
  Matrizen. 
\item Indizes aller Zeilen und Spalten erhalten, in denen Nichtnullelemente stehen: 
\begin{lstlisting}
[I,J] = find(X)
\end{lstlisting}
\item Eine \"Ubesicht aller Funktionen f\"ur d\"unnbesetzte Matrizen erh\"alt
  man durch \alert{ \mcode{help sparfun}}.  
\end{itemize}
\end{frame}

\end{document}
 

