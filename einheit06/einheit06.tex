\documentclass[hyperref={dvipdfmx,pdfpagelabels=false}]{beamer}
\title{Einführung in Matlab - Einheit 5}
\subtitle{Numerische Mathematik, profiler, objektorientierung}
\input{../slide_header}
\maketitle

\section{Numerische Mathematik}

\subsection{Poisson Problem}
%
% Slide
% 
\begin{frame}[fragile]\frametitle{Poisson Problem}
\begin{itemize}
\item Poisson Problem beschreibt station\"are W\"armeverteilungen.
\item {\it Poisson Problem:} Suche  $u \in
C^2(\Omega)\cap C(\overline{\Omega})$ mit
\[
\left \{ \begin{array}{rcll}
- \triangle u & = & f & \mbox{in } \Omega\\
u & = & 0 & \mbox{auf } \partial \Omega\\ 
\end{array} \right.
\]
f\"ur $\Omega=(0,1)^2$ und $f \in C(\Omega)$.
\item  {\it Laplace-Operator} 
$ \triangle u := \sum_{i=1}^d \frac{\partial ^2 u}{\partial x_i^2} $
\end{itemize}
\end{frame}
%
% Slide
% 
\begin{frame}[fragile]\frametitle{Diskretisierung}
\begin{itemize}
\item \"Aquidistante Gitterweite $h= \frac 1 N$,
$N \in \mathbb{N}$
\item Menge aller Gitterpunkte 
\[ Z_h := \left\{ (x,y) \in \overline{\Omega} \ \mid \ x=z_1h, \ y=z_2h \text{ mit }
z_1,z_2 \in \mathbb{Z} \right\}. \]
\item Innere Gitterpunkte: $\omega_h := Z_h \cap \Omega$
\end{itemize}
\end{frame}
%
% Slide
% 
\begin{frame}[fragile]\frametitle{Diskretisierung}
\begin{itemize}
\item Approximation von $ \frac{\partial ^2 u}{\partial
  x^2} (x,y)$
{\small \[ \frac{u(x -h,y) - 2 u(x,y) + u(x+h,y)}{h^2} = \frac{\partial ^2 u}{\partial
  x^2} (x,y) + \mathcal{O}(h^2) \]}
\item  Approximation von $ \frac{\partial ^2 u}{\partial
  y^2} (x,y)$
{\small \[ \frac{u(x ,y-h) - 2 u(x,y) + u(x,y+h)}{h^2} = \frac{\partial ^2 u}{\partial
  y^2} (x,y) + \mathcal{O}(h^2) \]}
\item Addition ergibt f\"ur $ \triangle u(x,y)$ die N\"aherung
{\footnotesize \[
 \frac{1}{h^2} \left( u(x,y-h) + u(x-h,y) - 4 u(x,y) + u(x,y+h) +
 u(x+h,y)  \right) 
\] }
\end{itemize}
\end{frame}
%
% Slide
% 
\begin{frame}[fragile]\frametitle{Diskretisierung}
\begin{itemize}
\item Definition $u_{i,j}:=u(ih,jh)$ ergibt an Gitterpunkten $(ih,jh)$
\[ -u_{i,j-1} - u_{i-1,j} + 4 u_{i,j} - u_{i+1,j} - u_{i,j+1} = h^2 f_{ij} \] 
mit $i,j \in \{ 1, \dots , N-1 \}$ und $f_{ij}:=f(ih,jh)$. 
\item Randbedingungen ergeben
$u_{0,i}=u_{N,i}=u_{i,0}=u_{i,N}=0$, $i=0, \dots ,N$.
\end{itemize}
\end{frame}

%
% Slide
% 
\begin{frame}[fragile]\frametitle{Diskretisierung}
\begin{itemize}
\item Lexikografische Sortierung der inneren Unbekannten 
{\small \[ \begin{array}{cccc}
(h,(N-1)h) & (2h,(N-1)h) & \hdots & ((N-1)h,(N-1)h)\\
\vdots & \vdots & \vdots & \vdots \\
(h,2h) & (2h,2h) & \hdots & ((N-1)h,2h)\\
(h,h), & (2h,h) & \hdots & ((N-1)h,h)\\
\end{array} \]
}
ergibt Vektor $U_{i+(N-1)(j-1)}=u_{i,j}$.
\end{itemize}
\end{frame}
%
% Slide
% 
\begin{frame}[fragile]\frametitle{Diskretisierung}
Lineares Gleichungssystem f\"ur $U=(U_i)_{i=1}^{(N-1)^2}$
\[ A U = F \]
mit 
\begin{itemize}
\item $F:=(f_i)_{i=1}^{(N-1)^2}$ mit $f_{i+(N-1)(j-1)}=f(ih,jh)$, $i,j \in \{1,
\dots ,N-1 \}$,
\item  \begin{eqnarray*} 
A & := & \frac{1}{h^2} tridiag(-I_{N-1}, T, -I_{N-1}) \in \mathbb{R}^{(N-1)^2
 \times (N-1)^2},\\
 T & := & tridiag(-1,4,-1) \in \mathbb{R}^{(N-1)\times (N-1)}. 
\end{eqnarray*}
\end{itemize}
\end{frame}
%
% Slide
% 
\begin{frame}[fragile]\frametitle{Implementierung}
\begin{lstlisting}
function loes = poisson (f,n)
f = fcnchk(f);
A = gallery('poisson',n-1); 
% Erzeuge rechte Seite und Mesh
loes.mesh = zeros(2,(n-1)^2);
F = zeros((n-1)^2,1);
for i = 1:(n-1)
    for j = 1:(n-1)
        F(i+(n-1)*(j-1)) = (1/n)^2*f(i/n,j/n);
        loes.mesh(:,i+(n-1)*(j-1)) = [i/n; j/n]; 
    end
end
% Loese das lineare System
loes.x = A \ F;
\end{lstlisting}
\end{frame}
%
% Slide
% 
\begin{frame}[fragile]\frametitle{Implementierung}
\begin{lstlisting}

% Ergaenze Randbedingungen
loes.x = [ loes.x; zeros(4*(n+1),1)];
loes.mesh = [loes.mesh, [zeros(1,n+1); 0:1/n:1]];
loes.mesh = [loes.mesh, [ones(1,n+1);  0:1/n:1]];
loes.mesh = [loes.mesh, [0:1/n:1; ones(1,n+1)]];
loes.mesh = [loes.mesh, [0:1/n:1; zeros(1,n+1)]];

% Plotten
plot3(loes.mesh(1,:),loes.mesh(2,:),loes.x,'*');
figure;
[X,Y] = meshgrid(0:1/n:1,0:1/n:1);
Fi = TriScatteredInterp(loes.mesh(1,:)', loes.mesh(2,:)',loes.x,'linear');
Z = Fi(X,Y);
surf(X,Y,Z); shading flat;
\end{lstlisting}
\end{frame}

%\begin{frame}[fragile]\frametitle{}
%bild
%\end{frame}

\subsection{Differentialgleichungen}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Gew\"ohnliche Differentialgleichungen}
Sei $I \subset \mathbb{R}$ ein Intervall. Bei einer gewöhnlichen Dgl. sucht man eine Funktion $y:I \
\longrightarrow \mathbb{R}^n$, so dass
\alert{ \[ \frac{d}{dt}y(t)=f(t,y(t)), t\in I\quad y(t_0)=y_0, \]}
wobei $y_0 \in \mathbb{R}^n$ ein vorgegebener Anfangswert an $t_0\in I$
und $f:I \times \mathbb{R}^n \longrightarrow \mathbb{R}^n$ die
rechte Seite ist. Au{\ss}erdem sei $ \frac{d}{dt}y(t) :=(\frac{\partial
  y_1(t)}{\partial t}, \dots, \frac{\partial
  y_n(t)}{\partial t})^t$. \\
\alert{Beispiele:}\\
{\scriptsize
$\frac{d}{dt} y(t) = y(t), \ y(t_0)=y_0$, \quad L\"osung:
$y(t)=y_0 e^{t-t_0}$\\
$\frac{d}{dt} y(t) = e^y \sin(t)$, \quad L\"osung: $y(t)=-\log( \cos(x)+C)$, $C+\cos(x)>0$ }
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Skalares Beispiel}
L\"ose f\"ur $0 \leq t \leq 3$ mit \alert{ ode45} die Dgl.
\alert{ \[ \frac{d}{dt} y(t) = -y(t)-5e^{-t}\sin5t, \quad y(0)=1. \]}
\begin{itemize}
\item Die rechte Seite als eigene Funktion:
\lstinputlisting{rechte_seite1.m}
\end{itemize}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Skalares Beispiel}
\begin{itemize}
\item Ausrechnen und Plotten
\lstinputlisting{dgl_example.m}
\end{itemize}
\begin{center}
\includegraphics[width=0.5\textwidth]{./figures/loesung_dgl1} 
\end{center}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{ODE in MATLAB} 
\begin{lstlisting}
[<t>,<y>] = ode45(<@fun>, <tspan>, <aw>, <options>)
\end{lstlisting}
\begin{itemize}
\item \mcode{@fun} steht f\"ur die rechte Seite der Dgl. (m-File).
\item $aw \in \mathbb{R}^n$ ist der Anfangswert.
\item $tspan$ gibt das Zeitintervall an, auf dem die Dgl. berechnet
  werden soll. Normalerweise ist es von der Form
  \mcode{tspan=[t_0, t_1]}. Dann wird die Dgl. auf dem Intervall $[t_0,
  t_1]$ berechnet (Anfangswert: $y(t_0)=aw$).
\item Rückgabewerte: Vektoren $t$ und Matrizen $y$. Dabei ist
  $y(:,i)$ die L\"osung an der Stelle $t(i)$. Die Punkte $t_i$ werden
  automatisch bestimmt.
\item Durch die optionale Angabe von \mcode{options} kann der L\"oser
  gezielt eingestellt werden. 
\item Spezifiziert man mehr als zwei Zeitpunkte in \mcode{tspan}, so gibt MATLAB die
  L\"osung genau an diesen Zeitschritten zur\"uck.
\end{itemize}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Optionen}
Die genauen Parameter der ODE-L\"oser k\"onnen durch\\

\begin{lstlisting}
options = odeset('Eigenschaft 1','Spez. 1',...
  'Eigenschaft 2','Spez. 2',...) 
\end{lstlisting}

gesteuert werden. Die wichtigsten Parameter sind \mcode{AbsTol}
(Default $10^{-6}$) und \mcode{RelTol} (Default: $10^{-3}$). \\[0.5cm]
\alert{Beispiel:}
\begin{lstlisting}
options = odeset('AbsTol',1e-7,'RelTol',1e-4)
\end{lstlisting}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Andere L\"oser}
\begin{tabular}{ccp{5.5cm}c}
\hline
L\"oser & Steifigkeit & Algorithmus & Ordnungen\\
\hline
\mcode{ode45} & nicht steif & Expliziter Runge-Kutta L\"oser &  4, 5 \\
\mcode{ode23} & nicht steif & Expliziter Runge-Kutta L\"oser &  2, 3 \\
\mcode{ode113} & nicht steif & Explizites Mehrschrittverfahren & 1 - 13\\
\mcode{ode15s} & steif & Implizites Mehrschrittverfahren& 1 - 5\\
\mcode{ode23s} & steif &Modifiziertes Rosenbrockverfahren& 2, 3\\
\mcode{ode23t} & mittel steif & implizite Trapez Regel& 2, 3\\
\mcode{ode23tb} & steif & Implizites Runge-Kutta Verf.& 2, 3\\
\end{tabular}
%Ein lineares DG System mit konstanten Koeffizienten heißt steif, wenn
%seine Eigenwerte alle negativen Realteil besitzen und sein Steifigkeitsquotient
%groß ist.
%Sei µ1 der betragsgrößte und µ2 der betragskleinste Realteil der Eigenwerte einer Jacobi-Matrix, 
%dann wird der Steifigkeitsquotient q dieser Matrix definiert durch:
%q = µ1/µ2
\end{frame}

\subsection{Lorenz-Gleichungen}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Die Lorenz-Gleichungen}
\begin{itemize}
 \item Chaostheorie / Schmetterlingseffekt.
\end{itemize}

\begin{eqnarray*}
\frac{d}{dt} y_1(t) & = & 10 (y_2(t) -y_1(t)) \\
\frac{d}{dt} y_2(t) & = & 28 y_1(t) -y_2(t) -y_1(t)y_3(t)\\ 
\frac{d}{dt} y_3(t) & = & y_1(t)y_2(t) -8y_3(t)/3
\end{eqnarray*}


rechte Seite:
\lstinputlisting{lorenz_rechte_seite.m}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Die Lorenz-Gleichungen}
\lstinputlisting{lorenz_gl.m}
\end{frame}
%
% Slide
%
\begin{frame}[fragile]\frametitle{Die Lorenz-Gleichungen}
\begin{center}
\includegraphics[width=0.8\textwidth]{./figures/lorenz}
\end{center}
\end{frame}

\subsection{Nichtlineare Gleichungen lösen und Optimierung}

\begin{frame}[fragile]\frametitle{Gleichungslöser}
Löst nichtlineare Gleichungen
\begin{lstlisting}
 [x,fval] = fsolve(fun,x0,options)
\end{lstlisting}


\end{frame}


\begin{frame}[fragile]\frametitle{Gleichungslöser - mit Nebenbedingungen}
\begin{lstlisting}
 x = fmincon(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options)
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]\frametitle{Minimumsuche - Ableitungsfrei}
ohne Nebenbedingungen, multidimensional:
\begin{lstlisting}
 [x,fval,exitflag,output] = fminsearch(f,x0,options)
\end{lstlisting}
\begin{itemize}
 \item \mcode{f}: Function handle.
\item \mcode{x0}: Start-wert/vektor/matrix.
\item \mcode{options}: Struktur der options (siehe \mcode{optimset}).
\end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{optimset}
\begin{lstlisting}
options = optimset('param1',value1,'param2',value2,..) 
\end{lstlisting}
\begin{itemize}
 \item \mcode{'TolFun'}: Abbruchkriterium für den Funktionswert.
\item \mcode{'TolX'}: Abbruchkriterium für aktuellen Punkt $x$.
\item \mcode{'MaxIter'}: Maximale Anzahl Iterationen.
\item \mcode{'Display'}: Regelt Ausgabe im Commandwindow.
\end{itemize}
\end{frame}




\section{Profiler}

\begin{frame}[fragile]\frametitle{Perfomance}

Perfomance der ist bei realen Problemen schnell ein wichtiger Aspekt um Software zu erhalten die das gegebene Problem gut und schnell löst.

\textbf{Einflussfaktoren:}
\begin{itemize}
 \item Algorithmus
 \item \alert{Implementation}
 \item Betriebssytem und Programmiersprache
 \item Hardware
\end{itemize}

\end{frame}

\begin{frame}[fragile]\frametitle{Profiler}
Tool um Bottlenecks und Fehler (Bugs) herauszufinden.

\textbf{Features}
\begin{itemize}
 \item (zeilenweise) Ausführungszeit
\item Eltern-Kind-Beziehungen der Funktionen und deren Ausführungszeit
 \item Anzahl Funktionsaufrüfe
\item Geschichte (History) der Funktionsaufrüfe
\item Farbige Darstellung und Frontend
\end{itemize}

\end{frame}

\begin{frame}[fragile]\frametitle{Benutzung}
\begin{lstlisting}
profile on 
<Befehle>
profile viewer
\end{lstlisting}
Optionen und Kommandos:
\begin{itemize}
 \item \mcode{-history}: Speichert die Funktionsaufruf-history.
 \item \mcode{-timer real}: Setzt die Zeitmessung auf Realzeit.
\item \mcode{-timer cpu}: Setzt die Zeitmessung auf CPU-Zeit.
 \item \mcode{resume}: Setzt den Profiler fort.
\end{itemize}

\end{frame}

\begin{frame}[fragile]\frametitle{Profiler - Beispiel}
\lstinputlisting{fout.m}
\lstinputlisting{profilertest.m}
\end{frame}

\begin{frame}[fragile]\frametitle{Profilerwindow}
\begin{center}
\includegraphics[width=0.8\textwidth]{./figures/profilertest}
\end{center}
\end{frame}

\begin{frame}[fragile]\frametitle{History der Funktionsaufrüfe}
\lstinputlisting{profilertest2.m}
\end{frame}

\begin{frame}[fragile]\frametitle{Profiling Poisson}
\lstinputlisting{profile_poisson.m}
\begin{center}
\includegraphics[width=0.7\textwidth]{./figures/profile_poisson}
\end{center}
\end{frame}


\end{document}